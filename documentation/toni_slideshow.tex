\documentclass[14pt, aspectratio=169]{beamer}

% sudo apt-get install texlive-lang-cyrillic
\usepackage[T2A,T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[main=bulgarian,english]{babel}
\usepackage{algorithm,algorithmic}

\usepackage{forest}
\usepackage{mathtools}
\forestset{
    parse tree/.style={for tree={s sep=0.5em, minimum size=0.5em}}
}

\renewcommand\thealgorithm{}
\newcommand{\setalglineno}[1]{\setcounter{ALC@line}{\numexpr#1-1}}

\graphicspath{ {./image/} }

\usetheme{Boadilla}
\usecolortheme{beaver}

% Hide the navigation buttons at the bottom of each slide
\setbeamertemplate{navigation symbols}{}

% Lets the boolet points for next slides to be seen
%\setbeamercovered{transparent}

% Increase the size of title in the footer
\makeatletter
\defbeamertemplate*{footline}{Dan P theme}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.2\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertshortauthor\expandafter\beamer@ifempty\expandafter{\beamer@shortinstitute}{}{~~(\insertshortinstitute)}
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertshorttitle
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.3\paperwidth,ht=2.25ex,dp=1ex,right]{date in head/foot}%
    \usebeamerfont{date in head/foot}\insertshortdate{}\hspace*{2em}
\insertframenumber{} / \inserttotalframenumber\hspace*{2ex}
  \end{beamercolorbox}}%
  \vskip0pt%
}
\makeatother

% Teach babel the tags to translate them
\usepackage{etoolbox}
\newtheorem{axiom}{Axiom}
\patchcmd{\theorem}{Theorem}{Teorema}{}{}
\patchcmd{\corollary}{Corollary}{Следствие}{}{}
\patchcmd{\lemma}{Lemma}{Лема}{}{}
\patchcmd{\proposition}{Proposition}{Предложение}{}{}
\patchcmd{\axiom}{Axiom}{Аксиома}{}{}
\patchcmd{\example}{Example}{Пример}{}{}
\patchcmd{\definition}{Definition}{Дефиниция}{}{}
\patchcmd{\remark}{Remark}{Забележка}{}{}

\newcommand\ST{\mathbb{T}}
\newcommand\SF{\mathbb{F}}
\newcommand\SB{\mathbb{B}}
\newcommand\M{\mathcal{M}}
\newcommand\F{\mathcal{F}}
\newcommand\p{\mathcal{P}}
\newcommand\V{\mathcal{V}}
\newcommand\E{\mathcal{E}}
\newcommand\Tb{\mathbf{T}}
\newcommand\Vb{\mathbf{V}}
\newcommand{\BranchConjunction}{%
\begin{equation*}
			\beta =
			\bigwedge_{\ST C(a,b)\in{\SB}} C(a, b) \:\: \wedge \:\:
			\bigwedge_{\ST d = 0\in{\SB}} d = 0 \:\: \wedge \:\:
			\bigwedge_{\SF C(e,f)\in{\SB}} \neg C(e, f) \:\: \wedge \:\:
			\bigwedge_{\SF g = 0\in{\SB}} g \neq 0
\end{equation*}%
}
\newcommand{\pair}[2]{ \langle #1, #2 \rangle }
\newcommand{\pairXY}{ \pair{x}{y} }
\newcommand{\pairXX}{ \pair{x}{x} }
\newcommand{\pairYX}{ \pair{y}{x} }
\newcommand{\pairYY}{ \pair{y}{y} }

\logo{\includegraphics[width=1cm]{fmi_logo.png}}

\date[\today]{}

\title{\textsc{Уеб система за изпълнимост на свързаната контактна логика}}

%\subject{}

%\institute{}

\author[Антон Дудов]{
	\textsc{Факултет по математика и информатика} \\
	\textsc{Катедра по математическа логика и приложенията ѝ} \\ [8mm]
	\textsc{Антон Дудов} \\ [8mm]
	\small\textsc{Научен ръководител: проф. Тинко Тинчев}
}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\tableofcontents
\end{frame}

\section{Табло метод за класическа съждителна логика}

% Табло методът има няколко приложения.
% Може да се използва за формално доказване, че дадена съждителна формула е тавтология.
% Алгоритъм за търсене на модел, в който формулата е изпълнима.
\begin{frame}{Табло метод за класическа съждителна логика}
Приложения:
\begin{itemize}
	\item<1-> Доказване, че формула е тавтология
	\begin{description}
		\item<2-> $\phi = x \lor \neg x$
	\end{description}

	\item<3-> Алгоритъм за търсене на модел % Алгоритъм за търсене на модел, в който формулата е изпълнима
	\begin{description}
		\item<4-> $\psi = (x \land \neg x) \lor (\neg x \land y) \rightarrow x = F ,\; y = T$
	\end{description}
\end{itemize}
\end{frame}

% Първо, трябва ни синтактичен способ, с който да покажем, че дадена формула не е изпълнима и да правим анализ по формулата.
% Ще следваме описанието на табло метода от книгата - Handbook of tableau methods за табло методите. Там биват два вида табла - със или без знаци. Ще ползваме версията със знаци.
% Знаците, с които ще маркираме формулите са F и T.
% Формулите със знаци са изрази от вида FX и TX

\begin{frame}{Табло метод за класическа съждителна логика}
	Табло метод със знаци $\ST$ и $\SF$
	\begin{itemize}
		\item $\ST X$ - означава, че формулата X трябва да е true (в някой модел)
		\item $\SF X$ - аналогично, X трябва да е false
	\end{itemize}
\end{frame}

\begin{frame}{Табло метод - правила за разбиване на подформули}
	\begin{itemize}
	\LARGE
		\item<1-> $\frac{\ST \neg X}{\SF X}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\ \frac{\SF \neg X}{\ST X}$
		\\ [8mm]
		\item<2-> $\frac{\ST X \land Y}{{\ST X \atop \ST Y}} \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\; \frac{\SF X \land Y}{\SF X \mid \SF Y}$
		\\ [8mm]
		\item<3-> $\frac{\ST X \lor Y}{\ST X \mid \ST Y} \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\ \frac{\SF X \lor Y}{{\SF X \atop \SF Y}}$
	\normalsize
	\end{itemize}
\end{frame}

\begin{frame}{Табло метод - правила за разбиване на подформули}
	\begin{itemize}
	\LARGE
		\item<1-> $\frac{\ST X \Rightarrow Y}{\SF X \mid \ST Y} \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\ \frac{\SF X \Rightarrow Y}{{\ST X \atop \SF Y}}$
		\\ [8mm]
		\item<2-> $\frac{\ST X \Leftrightarrow Y}{\left.{\ST X \atop \ST Y}\right\vert{\SF X \atop \SF Y}} \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\ \frac{\SF X \Leftrightarrow Y}{\left.{\ST X \atop \SF Y}\right\vert{\SF X \atop \ST Y}}$
	\normalsize
	\end{itemize}
\end{frame}

\begin{frame}{Табло метод - строене}
	\begin{center}
	\begin{forest}
		parse tree
		[$\ST ((x \land \neg x) \lor (\neg x \land y))$
			[$\ST (x \land \neg x)$ [$\ST x$ [$\ST \neg x$ [$\SF x$]]]]
			[$\ST (\neg x \land y)$ [$\ST \neg x$ [$\ST y$ [$\SF x$]]]]
		]
	\end{forest}
	\end{center}
\end{frame}

\begin{frame}{Табло метод - дефиниции}
	\begin{itemize}
		\item<1-> Клон се нарича \textbf{затворен}, ако съдържа противоречие.
		\item<2-> Клон се нарича \textbf{приключен}, ако всички формули в него са приложени, т.е. съдържа само променливи.
		\item<3-> Клон се нарича \textbf{отворен}, ако е приключен и не е затворен.
		\item<4-> \textbf{Затворено табло} е табло, на което всички клонове са затворени.
	\end{itemize}
\end{frame}

\begin{frame}{Табло метод - тавтология}
	\begin{lemma}
		Затворено табло за $\SF X$ е табло доказателство за X, т.е. Х е \textbf{тавтология}.
	\end{lemma}
	\small
	\begin{example}
		\begin{center}
		\begin{forest}
			parse tree
			[$\SF (x \lor \neg x)$ [$\SF x$ [$\SF \neg x$ [$\ST x$]]]]
		\end{forest}
		\end{center}
	\end{example}
\end{frame}

% В последствие ще използваме табло метода, за да намерим модел, в който дадена формула е изпълнима. Ще добавим няколко атомарни формули и ще търсим отворен клон. Ако не намерим такъв - нямаме модел за формулата. Ако има - формулата няма лексикални противоречия и почваме да строим модел удоволетворяващ атомарните формули в този клон.

% Всеки приключен клон в талбото е множество от атомарни формули. Таблото е множество от такива множества. Можем да си мислим за външното множество като дизункция на вътрешните множества, а вътрешните множества са  конюнкция на атомарни формули. По този начин таблото е генеризация на дизюнктивна нормална форма. По този начин преобразуваме формулата в дизюнктивна нормална форма.

\section{Контактна логика}
\subsection{Синтаксис}

\begin{frame}{Контактна логика - синтаксис}
	\begin{itemize}
		\item \textit{Булеви променливи} (изброимо множество $\V$)
		\item \textit{Булеви константи}: 0 и 1
		\item \textit{Булеви операции}:
		\begin{itemize}
			\item $\sqcap$ Сечение
			\item $\sqcup$ Обединение
			\item $^*$ Допълнение
		\end{itemize}
		\item \textit{Булеви термове}
		\item \textit{Логически връзки}: $\neg$, $\land$, $\lor$, $\Rightarrow$, $\Leftrightarrow$
		\item \textit{Логически константи}: $\top$ и $\bot$
		\item \textit{Модални връзки}: $\leq$(част от) and $C$(контакт)
		\item \textit{Формули}
	\end{itemize}
\end{frame}

\begin{frame}{Контактна логика - термове}
	\textbf{\textit{Терм - индуктивна дефиниция}}
	\begin{itemize}
		\item Булева променлива
		\item Булева константа
		\item Ако $a$ е терм, то $a^*$ също е терм
		\item Ако $a$ и $b$ са термове, то и $a \sqcap b$ и $a \sqcup b$ са също термове
	\end{itemize}
\end{frame}

\begin{frame}{Контактна логика - формули}
	\uncover<1->{
		\textbf{\textit{Атомарни формули}} са от вида $a \leq b$ and $aCb$, където $a$ и $b$ са термове.
	}

	\uncover<2->{
		\textbf{\textit{Формула - индуктивна дефиниция}}
		\begin{itemize}
			\item Логическа константа
			\item Атомарна формула
			\item Ако $\phi$ е формула, то $\neg\phi$  съшо е формула
			\item Ако $\phi$ и $\psi$ са формули, то ($\phi \land \psi$), ($\phi \lor \psi$), ($\phi \Rightarrow \psi$) and ($\phi \Leftrightarrow \psi$) са също формули
		\end{itemize}
	}
\end{frame}

\subsection{Семантика}

\begin{frame}{Контактна логика - семантика}
	\uncover<1->{
		$\F$ = (W, R) е релационна система с W $\neq$ $\emptyset$ и R $\subseteq$ $W^2$
	}

	\uncover<2->{
		\begin{definition}[Оценка]
			\textbf{\textit{Оценка}} на булеви променливи в $\F$ е всяка функция $\upsilon : \V \rightarrow \p(W)$. Разширяваме $\upsilon$ индуктивно за булевите термове:

			\begin{itemize}
				\item $\upsilon(0) = \emptyset$
				\item $\upsilon(1) = W$
				\item $\upsilon(a \sqcap b) = \upsilon(a) \cap \upsilon(b)$
				\item $\upsilon(a \sqcup b) = \upsilon(a) \cup \upsilon(b)$
				\item $\upsilon(a^*) = W \setminus \upsilon(a)$
			\end{itemize}
		\end{definition}
	}
\end{frame}

\begin{frame}{Контактна логика - част от}
	\begin{definition}[Част от]
		\begin{equation*}
			a \leq b \iff \upsilon(a) \subseteq \upsilon(b)
		\end{equation*}
		Където а и b са термове.
	\end{definition}
\end{frame}

\begin{frame}{Контактна логика - контакт}
	\begin{definition}[Контакт]
		\begin{equation*}
			aCb \iff (\exists x \in \upsilon(a))(\exists y \in \upsilon(b))(xRy)
		\end{equation*}
		Където а и b са термове.
	\end{definition}
\end{frame}

\subsection{Изпълнимост на формула}

\begin{frame}{Контактна логика - модел}
	\begin{definition}[Модел]
		$\M$ = ($\F, \upsilon$) се нарича \textbf{\textit{модел}}.

		Истиността на формула $\phi$ в $\M$ ($\M \models \phi$) се разширява индуктивно за всички термове както следва:
		\begin{itemize}
			\item $\M \models \top$
			\item $\M \not\models \bot$
			\item $\M \models a \leq b \iff \upsilon(a) \subseteq \upsilon(b)$
			\item $\M \models aCb \iff (\exists x \in \upsilon(a))(\exists y \in \upsilon(b))(xRy)$
		\end{itemize}
	\end{definition}
\end{frame}

\begin{frame}{Контактна логика - модел}
	\begin{definition}[Модел]
		\begin{itemize}
			\item $\M \models \neg \phi \iff \M \not\models \phi$
			\item $\M \models \phi \land \psi \iff \M \models \phi$ and $\M \models \psi$
			\item $\M \models \phi \lor \psi \iff \M \models \phi$ or $\M \models \psi$
			\item $\M \models \phi \Rightarrow \psi \iff \M \not\models \phi$ or $\M \models \psi$
			\item $\M \models \phi \Leftrightarrow \psi \iff$ ($\M \models \phi$ and $\M \models \psi$) or ($\M \not\models \phi$ and $\M \not\models \psi$)
		\end{itemize}
	\end{definition}
\end{frame}

\begin{frame}{Контактна логика - изпълнимост на формула}
	\uncover<1->{
		\begin{definition}[Модел на формула]
			Модел $\M$ е \textit{\textbf{модел на формулата}} $\phi$, ако $\phi$ е \textit{вярвна (изводима)} в $\M$.
		\end{definition}
	}

	\uncover<2->{
		\begin{definition}[Изпълнимост на формула]
			Ако $\phi$ има модел $\M$, то $\phi$ е \textbf{изпълнима}.
		\end{definition}
	}
\end{frame}

\begin{frame}{Контактна логика}
	Нека a и b са термове.
	\uncover<1->{
		\begin{lemma}[Равенство на термове]
			\begin{equation*}
				a = b \implies \upsilon(a) = \upsilon(b)
			\end{equation*}
		\end{lemma}
	}

	\uncover<2->{
		\begin{lemma}[Нулев терм]
			\begin{equation*}
				a \leq b \implies a \sqcap b^*=0
			\end{equation*}
		\end{lemma}
	}

	\uncover<3->{
		\begin{lemma}[Ненулев терм]
			\begin{equation*}
				\neg(a \leq b) \implies a \sqcap b^* \neq 0
			\end{equation*}
		\end{lemma}
	}
\end{frame}

\begin{frame}{Контактна логика - свойства на релацията}
	Нека a и b са термове.
	\uncover<1->{
		\begin{axiom}[Рефлексивност]
			\begin{equation*}
				a \neq 0 \implies aCa
			\end{equation*}
		\end{axiom}
	}

	\uncover<2->{
		\begin{axiom}[Симетричност]
			\begin{equation*}
				aCb \iff bCa
			\end{equation*}
		\end{axiom}
	}
\end{frame}

\begin{frame}{Табло - отворен клон}
	\uncover<1->{
		\begin{center}
			Формула $\phi \rightarrow$ табло с начало $\phi \rightarrow$ отворен клон $\SB$.
		\end{center}
	}

	\only<2>{
		$\SB$ е множество състоящо се от следните атомарни формули
		\begin{itemize}
			\item $\ST C(a,b)$
			\item $\SF C(e,f)$
			\item $\ST a \leq b$
			\item $\SF a \leq b$
		\end{itemize}
	}

	\only<3>{
		$\SB$ е множество състоящо се от следните атомарни формули
		\begin{itemize}
			\item $\ST C(a,b)$ $\rightarrow$ $C(a,b)$ (контакт)
			\item $\SF C(a,b)$ $\rightarrow$ $\neg C(a,b)$ (не-контакт)
			\item $\ST a \leq b$ $\rightarrow$ $a \leq b$ $\rightarrow$ $a \sqcap b^*=0$ $\rightarrow$ $g = 0$ (нулев терм)
			\item $\SF a \leq b$ $\rightarrow$ $\neg (a \leq b)$ $\rightarrow$ $a \sqcap b^* \neq 0$ $\rightarrow$ $d \neq 0$ (ненулев терм)
		\end{itemize}
	}
\end{frame}

\subsection{Алгоритъм за строене на модел}

\begin{frame}{Строене на модел}
	\uncover<1->{
		\begin{definition}[Отворен клон $\beta$]
			\BranchConjunction
		\end{definition}
	}

	\uncover<2->{
		\begin{center}
			Ако $\beta$ има модел $\M = (\F, \upsilon) = ((W, R), \upsilon)$, то $\M$ е и модел за формулата $\phi$
		\end{center}
	}
\end{frame}

\begin{frame}{Модални точки}
	$\upsilon : \V \rightarrow \p(W)$
	\begin{itemize}
		\item $\upsilon(0) = \emptyset$ \;\;\;\;\;\;\;\;\;\;\;\; $\upsilon(1) = W$  \;\;\;\;\;\;\;\;\;\;\;\; $\upsilon(a^*) = W \setminus \upsilon(a)$
		\item $\upsilon(a \sqcap b) = \upsilon(a) \cap \upsilon(b)$  \;\;\;\;\;\;\;\;\;\;\;\; $\upsilon(a \sqcup b) = \upsilon(a) \cup \upsilon(b)$
	\end{itemize}

	\begin{definition}[Модална точка]
		Оценка на променливи $\E_n$ за $n$ булеви променливи е поредици от единици и нули както следва:
		\begin{equation*}
			\E_n = \; < e_1, e_2, \ldots , e_n >, \; where \; e_1, \ldots, e_n \in \{0, 1 \}
		\end{equation*}
		\textbf{Модална точка} е оценка на променливи $\E_n$
	\end{definition}
\end{frame}

\begin{frame}{Модални точки}
	\uncover<1->{
		\begin{definition}[$W_n$]
			Множеството от всички модални точки за n променливи е \textbf{$W_n$}
			\begin{equation*}
				W_n = \{< e_1, e_2, \ldots , e_n > \mid e_1, \ldots, e_n \in \{0, 1 \} \}
			\end{equation*}
			$|W_n| = 2^n$
		\end{definition}
	}

	\uncover<2->{
		\begin{definition}
			$(\E_n)^i$ e i-тия елемент в поредицата $\E_n$.
		\end{definition}
	}
\end{frame}

\begin{frame}{Оценка}
	\textbf{Оценка $\upsilon : \V \rightarrow \p(W)$}:
	\begin{equation*}
		\upsilon(x) = \{ \E \mid \E \in W \; and \; (\E)^i = 1 \}, \;\; x \in \V
	\end{equation*}
	Разширява се индуктивно както следва:
	\begin{itemize}
		\item $\upsilon(0) = \emptyset$
		\item $\upsilon(1) = W$
		\item $\upsilon(a \sqcap b) = \upsilon(a) \cap \upsilon(b)$
		\item $\upsilon(a \sqcup b) = \upsilon(a) \cup \upsilon(b)$
		\item $\upsilon(a^*) = W \setminus \upsilon(a)$
	\end{itemize}
\end{frame}

\begin{frame}{Изпълнимост на атомарни формули}
	\uncover<1->{
		\begin{lemma}[Изпълнимост на нулевите термове]
			\begin{equation*}
				g = 0 \in \beta \rightarrow \upsilon(g) = \emptyset
			\end{equation*}
		\end{lemma}
	}

	\uncover<2->{
		\begin{lemma}[Изпълнимост на не-контактите]
			\begin{equation*}
				\neg C(e, f) \in \beta \rightarrow \neg(\exists x \in \upsilon(e))(\exists y \in \upsilon(f))(xRy)
			\end{equation*}
		\end{lemma}
	}
\end{frame}

\begin{frame}{Валидна модална точка}
	\uncover<1->{
	\begin{definition}[Валидна модална точка]
		$\E \in W_n$ е \textbf{валидна модална точка} на $\beta$, ако запазва изпълнимостта на нулевите термове и не-контактите
			\begin{equation*}
				g = 0 \in \beta \rightarrow \E_n \notin \upsilon_n(g) И
			\end{equation*}
			\begin{equation*}
				\neg C(e, f) \in \beta \rightarrow \E_n \notin (\upsilon_n(e) \cap \upsilon_n(f))
			\end{equation*}
	\end{definition}
	}

	\uncover<2->{
		\begin{definition}[$W^v$]
			Множеството от всички валидни модални точки е \textbf{$W^v$}
			\begin{center}
				$W^v = \{ \E \mid \E \in W_n$ и $\E$ е валидна модална точка на $\beta \}$
			\end{center}
		\end{definition}
	}
\end{frame}

\begin{frame}{Валидна релация между точки}
	\uncover<1->{
		\begin{definition}[Валидна релация]
			Нека х, y $\in W^v$. Тогава $\pairXY$ е \textbf{валидна релация} на $\beta$, ако запазва изпълнимостта на не-контактите в $\beta$.
			\begin{center}
				$\neg C(e, f) \in \beta \rightarrow \neg(x \in \upsilon(e)$ и $y \in \upsilon(f))$ или $(x \in \upsilon(f)$ и $y \in \upsilon(e))$
			\end{center}
		\end{definition}
	}

	\uncover<2->{
		\begin{definition}[IsValidCon]
			$IsValidCon: (W^v \times W^v) \rightarrow \{0, 1 \}$
			\begin{center}
				$IsValidCon(x,y) = 1 \iff \pairXY$ е валидна релация
			\end{center}
		\end{definition}
	}
\end{frame}

\begin{frame}{Точка част от оценка}
		\begin{definition}[$\eta$]
			$\eta: (\Tb \times W_n) \rightarrow \{0, 1 \}$ - указва дали модална точка е част от оценката на терм. Нека $t \in \Tb$ и $\E \in W_n$.
			\begin{itemize}
				\item $\eta(0, \E) = 0$
				\item $\eta(1, \E) = 1$
				\item $\eta(x_i, \E) = 1 \iff (\E)^i = 1$
				\item $\eta(a \sqcap b, \E) = 1 \iff \eta(a, \E) = 1 \; and \; \eta(b, \E) = 1$
				\item $\eta(a \sqcup b, \E) = 1 \iff \eta(a, \E) = 1 \; or \; \eta(b, \E) = 1$
				\item $\eta(a^*, \E) = 1 \iff \eta(a, \E) = 0$
			\end{itemize}
		\end{definition}
\end{frame}

\begin{frame}{Точка част от оценка}
	\begin{lemma}
		Нека $t \in \Tb$ и $\E \in W_n$.
		\begin{equation*}
			\eta(t, \E) = 1 \iff \E \in \upsilon(t)
		\end{equation*}
	\end{lemma}
\end{frame}

\begin{frame}
	\begin{algorithm}[H]
	\renewcommand\thealgorithm{} % Remove the algotihm #number
	\begin{algorithmic}[1] % [1] Adds line numbering
		\STATE $W \gets \emptyset$
		\STATE $R \gets \emptyset$
		\FOR{$d \neq 0 \in \beta$} \label{non-zero-terms}
			\FOR{$\E \in W^v$}
				\IF{$\eta(d, \E_n) = 1$}
					\STATE $W \gets W \cup \{ x \}$
					\STATE $R \gets R \cup \{ \pairXX \}$
					\STATE go to \ref{non-zero-terms}
				\ENDIF
			\ENDFOR
			\STATE Не може да се създаде модел.
		\ENDFOR
	\end{algorithmic}

	\caption{Алгоритъм за строене на модел}
	\label{alg:seq}
	\end{algorithm}
\end{frame}

\begin{frame}
	\begin{algorithm}[H]
	\renewcommand\thealgorithm{} % Remove the algotihm #number
	\begin{algorithmic}[1] % [1] Adds line numbering
		\setalglineno{13}
		\FOR{$C(a, b) \in \beta$} \label{contacts}
			\FOR{$x,\; y \in W^v$}
				\IF{$\eta(a, x) = 1 \land \eta(b, x) = 1 \land IsValidCon(x,y)$}
					\STATE $W \gets W \cup \{x, y \}$
					\STATE $R \gets R \cup \{\pairXX, \pairYY, \pairXY, \pairYX \}$
					\STATE go to \ref{contacts}
				\ENDIF
			\ENDFOR
			\STATE Не може да се създаде модел.
		\ENDFOR
		\STATE Успешно е създаден модел $\M = ((W, R), \upsilon)$.
	\end{algorithmic}

	\caption{Алгоритъм за строене на модел}
	\label{alg:seq}
	\end{algorithm}
\end{frame}

\section{Свързана контактна логика}

\begin{frame}{Свързана контактна логика}
\end{frame}

\subsection{Свързаност}
\subsection{Алгоритъм за строене на свързан модел}

\section{Имплементация}
\subsection{Строене на формула от текст}
\subsection{Строене на свързан модел}
\subsection{Сървър и уеб приложение}
\subsection{Автоматична компилация, тестване и среда}

\end{document}