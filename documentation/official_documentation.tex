\documentclass{article}
\usepackage{amssymb}
\usepackage{newtxtext}
\usepackage{newtxmath}
\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\title{Satisfiability Of Modal Logic Formulas}
\date{2019-9-28}
\author{Martin Stoev, Anton Dudov}

\begin{document}
	\maketitle
	\pagenumbering{gobble}
	\newpage

	\section{Formula Representation}
	Let $\mathbb{V}ar$ be the set of variables:
	\[ \mathbb{V}ar = \{p_0, p_1, p_2 ... \}\]
	Let $\mathbb{C}_t$ be the set of Term constants:
	\[ \mathbb{C}_t = \{0, 1 \}\]
	\subsection{Term recursive definition}
	\begin{itemize}
		\item $a \in \mathbb{C}_t$ is a term
		\item $p \in \mathbb{V}ar$ is a term
		\item If x is a term, then $\bar{x}$ is a term as well
		\item If x and y are terms, then $x \sigma y $ is a term as well,\\
			where $\sigma \: \in \: \{\sqcap, \sqcup\}$
	\end{itemize}
	Let $\mathbb{C}_f$ be the set of formula constants:
	\[ \mathbb{C}_f = \{T, F \}\]
	\subsection{Formula recursive definition}
	\begin{itemize}
		\item $a \in \mathbb{C}_f$ is a formula
		\item If x and y are terms, then C(x, y) is a formula
		\item If x and y are terms, then $x \le y$ is a formula
		\item If x and y are terms, then $x \le_m y$ is a formula
		\item If $\phi$ is a formula, then $\neg \phi$ is a formula as well
		\item If $\phi$ and $\psi$ are formulas, then $\phi \: \sigma \: \psi $ is a formula as well,\\
			where $\sigma \in \{\vee, \wedge, \rightarrow, \leftrightarrow\}$
	\end{itemize}
	
		\subsection{Definition: Atomic Formula}
			A formula will be called atomic formula if it is a constant or it is in one of the followings:
			\begin{itemize}
				\item C(x, y)
				\item $x \le y$
				\item $x \le_m y$
			\end{itemize}
			where x and y are terms.

		\subsection{Definition/Theorem: Zero Term Formula}
			Let x and y be two terms, then:
			\begin{equation}
				x \le y  \iff x \sqcap \bar{y} = 0
			\end{equation}
			A formula in the form $x \sqcap \bar{y} = 0$ will be called Zero Term Formula.

	\section{Tableaux}
	The Tableaux process is decision procedure, which recursively breaks down a given formula into basic components 
	based on which a decision can be concluded. The recursive step which breaks down a formula creates one or two 
	new formulas, which in terms of their structure are simpler then the initial formula. Since the recursive step can create
	at most two new formulas, this means the recursive step will create at most two branches or a binary tree, where the nodes
	are the formulas and the links represent the recursive step. The different branches are considered to be disjuncted while
   	nodes of the same branch are considered in conjunction. The procedure modifies the tableau in such a way that the 
	formula represented by the resulting tableau is equivalent to the original one.

	Contradiction may arise when in the same branch, on some step there exists a formula and the negation of the same formula.
	If in some branch there exists a contradiction, then that branch closes. If all branches close then the proof is complete.
	
	The main principle of the tableaux is to break complex formulae into smaller ones until complementary pairs of literals are
	produced or no further expansion is possible.

	\subsection{Definition: Tableaux Step}
		The Tableaux Step takes as input a formula and a set of accumulated formulae and produces as 
		output one or two new formulae, depending on the operation. 
		The set of accumulated formulae consist of the broken down formulae by previous tableaux steps.
		The output of the tableaux step depends on the rule applied to the formula.

		\subsubsection*{Definition: Marked Formula} 
			Let $\varphi$ be a formula and X be the set of accumulated formulae, then $\varphi$ is said to be marked as:
			\begin{itemize}
				\item true if and only if $\mathbb{T}\varphi$
				\item false if and only if $\mathbb{F}\varphi$
			\end{itemize}

		\subsubsection*{Definition: Accumulated Formulae}
			The accumulated formulae set consists only of marked formulae and the letter X will be usually used for its representation.

		\subsubsection{Rules}
		\subsubsection*{Negation}
			$\begin{array}{rl}
				& \mathbb{T}(\neg \varphi), X \\
			      \cline{2-2}
			      & \mathbb{F}(\varphi), X
			\end{array}$
			\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
			$\begin{array}{rl}
				& \mathbb{F}(\neg \varphi), X \\
			      \cline{2-2}
			      & \mathbb{T}(\varphi), X
			\end{array}$

		\subsubsection*{And}
			$\begin{array}{rl}
				& \mathbb{T}(\varphi \: \wedge \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, \mathbb{T}\psi, X
			\end{array}$
			\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
			$\begin{array}{rl}
				& \:\:\: \mathbb{F}(\varphi \: \wedge \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{F}\varphi, X \:\:\:\:\:\:\:\: \mathbb{F}\psi, X
			\end{array}$

		\subsubsection*{Or}
			$\begin{array}{rl}
				& \:\:\: \mathbb{T}(\varphi \: \vee \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, X \:\:\:\:\:\:\:\: \mathbb{T}\psi, X
			\end{array}$
			\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
			$\begin{array}{rl}
				& \mathbb{F}(\varphi \: \vee \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{F}\varphi, \mathbb{F}\psi, X
			\end{array}$

		\subsubsection*{Implication}
			$\begin{array}{rl}
				& \:\:\: \mathbb{T}(\varphi \: \rightarrow \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{F}\varphi, X \:\:\:\:\:\:\:\: \mathbb{T}\psi, X
			\end{array}$
			\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
			$\begin{array}{rl}
				& \mathbb{F}(\varphi \: \rightarrow \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, \mathbb{F}\psi, X
			\end{array}$

		\subsubsection*{Equivalence}
			$\begin{array}{rl}
				& \:\:\:\:\:\:\:\: \mathbb{T}(\varphi \: \leftrightarrow \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, \mathbb{T}\psi, X \:\:\:\:\:\:\:\: \mathbb{F}\varphi, \mathbb{F}\psi, X
			\end{array}$
			\:\:\:\:\:\:\:\:\:\:
			$\begin{array}{rl}
				& \:\:\:\:\:\:\:\: \mathbb{F}(\varphi \: \leftrightarrow \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, \mathbb{F}\psi, X \:\:\:\:\:\:\:\: \mathbb{F}\varphi, \mathbb{T}\psi, X
			\end{array}$
		\newline
		\newline
		\newline
		The final output of the Tableaux process is "False" when all branches are closed or a set of atomic formulae, when there exists a branch which is not closed.
		\newline
	
		For our usecases the functionality of the tableaux process shall be extended to achive better results, since if the branch is not closed, there are 
		additional calculations needed in order to verify that there is no contradiction, namely to verify that there is no contradiction on Term level.
		This verification can be done in different manners, depending on the algorithm type. The best way to think about it is to have the tableaux process
		return a list, where each element is the set of atomic formulae found in a specific branch. This way the atomic formulae for each branch are produced, and 
		afterwards can be used in different algorithms. This is just an example, a way of thinking about the problem the real implementation is much more space 
		efficient.

	\subsection{Tableaux implementation}
		The programming implementation of the tableaux method follows the standard tableaux process explaned above.

		First interesting design decision is to keep all true formulae in one data set, and all false formulae in another data set.
		This enables fast searches wheter a formula has been marked as true or false.
		
		\subsubsection*{Definition: Marked Formula Collection}
			Let X be a set of formulae, then X is called marked formula collection if and only if all formulae in X are marked as true 
			or all formulae are marked as false.

			This collection is implemented with unordered\_map (hashmap),
			which stores the formulae by pointers to them, uses their precalculated hash and operator== to compare them.
			The average complexity for search, insert and erase in this collection is O(1).
		\newline
		\newline
		There exist 8 important marked formula collections:
%Note add definition for positive and negative collections !!!
		\begin{itemize}
			\item formulas\_T\_ - contains only formulae marked as true
			\item formulas\_F\_ - contains only formulae marked as false, \\
				For example, if $\neg\varphi$ is encountered as an output of the tableaux step, then only $\varphi$ is inserted into the formula\_F\_
			\item contacts\_T\_ - contains only contacts formulae marked as true
			\item contacts\_F\_ - contains only contacts formulae marked as false
			\item zero\_terms\_T\_ - contains only formulae of type $\varphi \le \psi$ marked as true
			\item zero\_terms\_F\_ - contains only formulae of type $\varphi \le \psi$ marked as false
			\item measured\_less\_eq\_T\_ - contains only formulae of type $\varphi \le_m \psi$ marked as true
			\item measured\_less\_eq\_F\_ - contains only formulae of type $\varphi \le_m \psi$ marked as false
		\end{itemize}

		\subsubsection*{Definition: Formula Contradiction}
			Let $\varphi$ be a marked formula, then $\varphi$ is causing a contradiction if any of the followings is true:
			\begin{itemize}
				\item $\varphi$ is marked as true and $\varphi \in$ formulas\_F\_
				\item $\varphi$ is marked as false and $\varphi \in$ formulas\_T\_
				\item $\varphi$ is a contact formula marked as true and $\varphi \in$ contacts\_F\_
				\item $\varphi$ is a contact formula marked as false and $\varphi \in$ contacts\_T\_
				\item $\varphi$ is a zero terms formula marked as true and $\varphi \in$ zero\_terms\_F\_
				\item $\varphi$ is a zero terms formula marked as false and $\varphi \in$ zero\_terms\_T\_
				\item $\varphi$ is a measured less formula marked as true and $\varphi \in$ measured\_less\_eq\_F\_
				\item $\varphi$ is a measured less formula marked as false and $\varphi \in$ measured\_less\_eq\_T\_

			\end{itemize}

		\subsubsection*{Invariant}
			At any time, all formulae in all eight marked formula collections do not contradict.

			A contradiction may occure if a formula is split and some of the resulting components causes a contradiction.

		\subsubsection*{Example}
			Let's assume that contacts\_T\_ = \{ C(a, b)\} and let's have a look at the following formula $\mathbb{T}(T \wedge \neg C(a,b))$.

			By the rules of decomposition, namely the ( $\wedge$ ) rule will produce $\mathbb{T}T, \mathbb{T}\neg C(a,b)$. 

			Then the $\mathbb{T}\neg C(a,b)$ will be decomposed to $\mathbb{F} C(a,b)$ by the ( $\neg$ ) rule, which causes a contradiction
			since C(a,b) is already present in contacts\_T\_ formulae

		\subsubsection*{Tableaux Algorithm}
			Given a formula $\varphi$, the following algorithm determines final atomic formulae in all branches of the tableaux process.

			As a first step if the formula $\varphi$ is the constant F, then false is returned directly, otherwise the whole formula $\varphi$ is inserted in formulas\_T\_.
		\newline
			\subsubsection*{Remarks}
			\begin{itemize}
				\item true boolean value is used to represent the formula constant T
				\item false boolean value is used to represent the formula constant F
				\item The commutativity of the contacts: C(a,b) == C(b,a)
			\end{itemize}
			Few lemmas which will provide a much more efficient contradiction finding in the tableaux process.
			\subsubsection*{Lemma: A}
				Let x be a term, suppose that the atomic formula x = 0 has already been marked as true,
				then marking the following formulae as true will lead to contradiction:
				\begin{itemize}
					\item C(x,y)
					\item C(y,x)
				\end{itemize}
				for some arbitrary term y.

			\subsubsection*{Lemma: A-inverse}
				Let x, y and z be terms, suppose that the atomic formulae C(x,y) or C(z, x) has already been marked as true,
				then marking the formula x = 0 as true will lead to contradiction.
				
			\subsubsection*{Lemma: Complexity A and A-inverse} 
				The algorithmic complexity to check whether a new formula leads to contradiction by Lemma A and Lemma A-inverse is done
				effectively, namely in constant time with the usage of one new collection contact\_T\_terms\_ which keeps the terms of 
				the true contacts, namely the contacts in in the collection contacts\_T\_. This means that for each $\mathbb{T}(C(x, y))$, the 
				terms x and y are in the mentioned collection of true terms. The contact\_T\_terms\_  is a multiset and keeps track 
				of all added terms, meaning that if the term x is added twice and then removed only once there will still be an entry of 
				that x in the contact\_T\_terms\_ collection.
				
				To check if a new formula leads to contradiction by Lemma A or Lemma A-inverse the following method is used:
				\begin{lstlisting}
auto has_broken_contact_rule(const formula* f) const -> bool;
				\end{lstlisting}

			\subsubsection{Handy methods}
			\subsubsection*{Find formula}
			\subsubsection*{Find formula marked as true}
				\begin{lstlisting}
auto find_in_T(const formula* f) const -> bool
				\end{lstlisting}
				Checks if the formula $\varphi$ exists in any positive collection depending on the type of $\varphi$, namely
				if $\varphi$ is of type:
				\begin{itemize}
					\item C(x, y), then return true $\iff \varphi \in contacts\_T\_$
					\item $x \le y$, then return true $\iff \varphi \in zero_terms\_T\_$
					\item $x \le_m y$, then return true $\iff \varphi \in measured_less_eq\_T\_$
					\item $\neg \psi$, then return true $\iff \varphi \in formulas\_T\_$
					\item $\psi_1 \sigma \psi_2$, where $\sigma \in \{\wedge, \vee\}$, then return true $\iff \varphi \in formulas\_T\_$
				\end{itemize}
			\subsubsection*{Find formula marked as false}
				\begin{lstlisting}
auto find_in_F(const formula* f) const -> bool
				\end{lstlisting}
				Checks if the formula $\varphi$ exists in any negative collection depending on the type of $\varphi$, namely
				if $\varphi$ is of type:
				\begin{itemize}
					\item C(x, y), then return true $\iff \varphi \in contacts\_F\_$
					\item $x \le y$, then return true $\iff \varphi \in zero_terms\_F\_$
					\item $x \le_m y$, then return true $\iff \varphi \in measured_less_eq\_F\_$
					\item $\neg \psi$, then return true $\iff \varphi \in formulas\_F\_$
					\item $\psi_1 \sigma \psi_2$, where $\sigma \in \{\wedge, \vee\}$, then return true $\iff \varphi \in formulas\_F\_$
				\end{itemize}
			\subsubsection*{Add formula}
			\subsubsection*{Mark formula as true}
				\begin{lstlisting}
void add_formula_to_T(const formula* f)
				\end{lstlisting}
				Adds the formula $\varphi$ as true in in the respective positive collection, namely
				if $\varphi$ is of type:
				\begin{itemize}
					\item C(x, y), then $\varphi$ is added to contacts\_T\_, and the terms x and y are added to the contact\_T\_terms\_ collection.
					\item $x = 0$, then x is added in zero\_terms\_T\_
					\item $x \le_m y$, then $\varphi$ is added to measured\_less\_eq\_T\_
					\item $\neg \psi$, then $\varphi$ is added to formulas\_T\_
					\item $\psi_1 \sigma \psi_2$, where $\sigma \in \{\wedge, \vee\}$, then $\varphi$ is added to formulas\_T\_
				\end{itemize}
			\subsubsection*{Mark formula as false}
				\begin{lstlisting}
void add_formula_to_F(const formula* f)
				\end{lstlisting}
				Adds the formula $\varphi$ as false in in the respective negative collection, namely
				if $\varphi$ is of type:
				\begin{itemize}
					\item C(x, y), then $\varphi$ is added to contacts\_F\_.
					\item $x = 0$, then x is added in zero\_terms\_F\_
					\item $x \le_m y$, then $\varphi$ is added to measured\_less\_eq\_F\_
					\item $\neg \psi$, then $\varphi$ is added to formulas\_F\_
					\item $\psi_1 \sigma \psi_2$, where $\sigma \in \{\wedge, \vee\}$, then $\varphi$ is added to formulas\_F\_
				\end{itemize}
			\subsubsection*{Remove formula}
			\subsubsection*{Remove formula marked as true}
				\begin{lstlisting}
void remove_formula_from_T(const formula* f)
				\end{lstlisting}
				Removes the formula $\varphi$ from the respective positive collection, namely
				if $\varphi$ is of type:
				\begin{itemize}
					\item C(x, y), then $\varphi$ is removed from contacts\_T\_, and the terms x and y are removed from the contact\_T\_terms\_ collection.
					\item $x = 0$, then x is removed from zero\_terms\_T\_
					\item $x \le_m y$, then $\varphi$ is removed from measured\_less\_eq\_T\_
					\item $\neg \psi$, then $\varphi$ is removed from formulas\_T\_
					\item $\psi_1 \sigma \psi_2$, where $\sigma \in \{\wedge, \vee\}$, then $\varphi$ is removed from formulas\_T\_
				\end{itemize}
			\subsubsection*{Remove formula marked as true}
				\begin{lstlisting}
void remove_formula_from_F(const formula* f)
				\end{lstlisting}
				Removes the formula $\varphi$ from the respective negative collection, namely
				if $\varphi$ is of type:
				\begin{itemize}
					\item C(x, y), then $\varphi$ is removed from contacts\_F\_
					\item $x = 0$, then x is removed from zero\_terms\_F\_
					\item $x \le_m y$, then $\varphi$ is removed from measured\_less\_eq\_F\_
					\item $\neg \psi$, then $\varphi$ is removed from formulas\_F\_
					\item $\psi_1 \sigma \psi_2$, where $\sigma \in \{\wedge, \vee\}$, then $\varphi$ is removed from formulas\_F\_
				\end{itemize}

	\newpage
\end{document}










































