\documentclass{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{newtxtext}
\usepackage{newtxmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage{makecell}
\usepackage{booktabs}% http://ctan.org/pkg/booktabs
\usepackage{float}

\restylefloat{table}
\newcommand{\tabitem}{~~\llap{\textbullet}~~}

\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\title{Satisfiability Of Modal Logic Formulas}
\date{2019-9-28}
\author{Martin Stoev, Anton Dudov}

\begin{document}
	\maketitle
	\pagenumbering{gobble}
	\newpage

	\section{Formula Representation}
	Let $\mathbb{V}ar$ be the set of variables:
	\[ \mathbb{V}ar = \{p_0, p_1, p_2 ... \}\]
	Let $\mathbb{C}_t$ be the set of Term constants:
	\[ \mathbb{C}_t = \{0, 1 \}\]
	\subsection{Term recursive definition}
	\begin{itemize}
		\item $a \in \mathbb{C}_t$ is a term
		\item $p \in \mathbb{V}ar$ is a term
		\item If x is a term, then $\bar{x}$ is a term as well
		\item If x and y are terms, then $x \sigma y $ is a term as well,\\
			where $\sigma \: \in \: \{\sqcap, \sqcup\}$
	\end{itemize}
	Parentheses are used to define the priority of an operation.

	Let $\mathbb{C}_f$ be the set of formula constants:
	\[ \mathbb{C}_f = \{T, F \}\]
	\subsection{Formula recursive definition}
	\begin{itemize}
		\item $a \in \mathbb{C}_f$ is a formula
		\item If x and y are terms, then C(x, y) is a formula
		\item If x and y are terms, then $x \le y$ is a formula
		\item If x and y are terms, then $x \le_m y$ is a formula
		\item If $\varphi$ is a formula, then $\neg \varphi$ is a formula as well
		\item If $\varphi$ and $\psi$ are formulas, then $\varphi \: \sigma \: \psi $ is a formula as well,\\
			where $\sigma \in \{\vee, \wedge, \rightarrow, \leftrightarrow\}$
	\end{itemize}

	\subsubsection*{Formula Parentheses}
		Parentheses are used to define the priority of an operation. They are defined for terms and formulae.
	
	\subsection{Definition: Atomic Formula}
		A formula will be called atomic formula if it is a constant or it is in one of the followings:
		\begin{itemize}
			\item C(x, y)
			\item $x \le y$
			\item $x \le_m y$
		\end{itemize}
		where x and y are terms.
	
	\subsection{Definition/Theorem: Zero Term Formula}
		Let x and y be two terms, then:
		\begin{equation}
			x \le y  \iff x \sqcap \bar{y} = 0
		\end{equation}
		A formula in the form $x \sqcap \bar{y} = 0$ will be called Zero Term Formula.


	\subsection{Parser}
		Flex and Bison are used to generate a parser with the modal logic grammar.
		Flex is used as a tokenizer while Bison is used as the parser.

		There are two types of building elements in the modal logic formula:
		\begin{itemize}
			\item terms, defined in \#REF Term Recursive Definition
			\item formulae, defined in \#REF Formula Recursive Definition
		\end{itemize}
		
	\subsubsection{Symbols Representation}
		\subsubsection*{Atomic terms}
		\begin{itemize}
			\item 0 is the term constant True
			\item 1 is the term constant False
			\item Arbitrary string is used to represent a variable
		\end{itemize}
		
		\subsubsection*{Terms operations}
		Let t1, t2 be terms, then the followings are the representations for term operations
		\begin{itemize}
			\item ~t1 is used to represent the complement term operation, namely $\bar{t1}$
			\item t1 * t2 is used to represent the intersection term operation, namely $t1 \: \sqcap \: t2$
			\item t1 * t2 is used to represent the union term operation, namely $t1 \: \sqcup \: t2$
		\end{itemize}
		
		\subsubsection*{Atomic formulae}
		Let t1, t2 be terms, then the followings are representation of atomic formulas
		\begin{itemize}
			\item T is the formula constant True
			\item F is the formula constant False
			\item C(t1, t2) is the contact operation
			\item <=(t1, t2) is the less or equal operation
			\item <=m(t1, t2) is the measured less or equal operation
			\item (t1)=0 is the equal to zero operation
		\end{itemize}

	\subsection{Tokenizer}
	\subsubsection*{Grammar}
		The tokenizer's grammar is pretty simple and is explaned in details in the following table:
		\begin{flushleft}
			\begin{tabular}{ | m{7em} | m{15em}| m{10em} | } 
				\hline
					[ \textbackslash t \textbackslash  n] & ; & Returns nothing, ignore all whitespace \\ 
				\hline
					[,TF01()C\&|~*+-] 	& {return yytext[0];} & all single charecter tokens will be passed as their ASCIIs for an easier use in bison \\
				\hline
				    "<="            &   {return T\_LESS\_EQ;} & Returns a special literal which maps the '<=' sequence \\
				\hline
				    "<=m"           &   {return T\_MEASURED\_LESS\_EQ;} & \\
				\hline
				    "=0"            &   {return T\_EQ\_ZERO;} & \\
				\hline
				    "= 0"           &   {return T\_EQ\_ZERO;} & \\
				\hline
				    "->"            &   {return T\_FORMULA\_OP\_IMPLICATION;} & \\
				\hline
				    "<->"           &   {return T\_FORMULA\_OP\_EQUALITY;} & \\
				\hline
				    [a-zA-Z0-9]+    &   \makecell{\{yylval->T\_STRING =\\ create\_lexer\_string(yytext, yyleng); \\ return T\_STRING;\}} & Returns T\_STRING literal type and the string  value is written to yylval which can be later accessed from the parser. Note that it uses our simple memory manager to allocate this string in order to be able to safely free all allocated strings even when some syntax error occures \\
				\hline
				    .               &   {return yytext[0];} & bison will trigger an error if it's unrecognized symbol \\
				\hline

			\end{tabular}
		\end{flushleft}

		\subsubsection*{Parser literals}
			The followings are definition of literals for multi character tokens
			\begin{itemize}
				\item \%token <const char*> T\_STRING is the literal for "string"
				\item \%token T\_LESS\_EQ is the literal for "<="
				\item \%token T\_MEASURED\_LESS\_EQ is the literal for "<=m"
				\item \%token T\_EQ\_ZERO is the literal for "=0"
				\item \%token T\_FORMULA\_OP\_IMPLICATION is the literal for "->"
				\item \%token T\_FORMULA\_OP\_EQUALITY is the literal for "<->"
			\end{itemize}

		\subsubsection*{Parser literals}
			The followings are definitions of priority and associativity of the operation tokens. 
			The priority is from low to hight (w.r.t. the line order in which they are defined)
			\begin{itemize}
				\item \%left T\_FORMULA\_OP\_IMPLICATION T\_FORMULA\_OP\_EQUALITY
				\item \%left '|' '+'
				\item \%left '\&' '*'
				\item \%right '~' '-'
				\item \%nonassoc '(' ')'
			\end{itemize}

		\subsubsection*{Parser grammar}
			In the process of parsing the formula the Abstract Syntax Tree(AST) is built as well, 
			which later is used to make formula modifications, for example converting X -> Y to ~X | Y .
			
			create\_formula\_node and create\_term\_node are two helper functions which construct AST nodes
			% go into details here about the create_formula_node and term_node


		\begin{lstlisting}
modal_logic_formula // The start non-terminal
    : formula {                   
        // $1 gives the matched formula and we write
        // it in a 'global' variable parsed_formula
        parsed_formula.reset($1); 
    }
  ;
formula // 'formula' non-terminal
    : 'T' { // trying to match token 'T'
        // $$ is the return value to the 'parent' 
        // who can use the matched subsequence
        $$ = create_formula_node(constant_true);   
    }
    | 'F' {
        $$ = create_formula_node(constant_false);
    }
    | 'C' '(' term ',' term ')' {                  
        // $3 and $5 gives the 'values' for the two 
        // matched terms (3 and 5 are their positions) 
        // and construct a contact node with them
        $$ = create_formula_node(contact, $3, $5); 
    }
    | "<=" '(' term ',' term ')' {
        $$ = create_formula_node(less_eq, $3, $5);
    }
    | "<=m" '(' term ',' term ')' {
        $$ = create_formula_node(measured_less_eq, $3, $5);
    }
    | term "=0" {
        $$ = create_formula_node(eq_zero, $1);
    }
    | '(' formula '&' formula ')' {
        $$ = create_formula_node(conjunction, $2, $4);
    }
    | formula '&' formula {
        $$ = create_formula_node(conjunction, $1, $3);
    }
    | '(' formula '|' formula ')' {
        $$ = create_formula_node(disjunction, $2, $4);
    }
    | formula '|' formula {
        $$ = create_formula_node(disjunction, $1, $3);
    }
    | '~' formula {
        $$ = create_formula_node(negation, $2);
    }
    | '(' formula "->" formula ')' {
        $$ = create_formula_node(implication, $2, $4);
    }
    | formula "->" formula {
        $$ = create_formula_node(implication, $1, $3);
    }
    | '(' formula "<->" formula ')' {
        $$ = create_formula_node(equality, $2, $4);
    }
    | formula "<->" formula {
        $$ = create_formula_node(equality, $1, $3);
    }
    | '(' formula ')' {
        $$ = $2;
    }
  ;
term
    : '1' {
        $$ = create_term_node(constant_true);
    }
    | '0' {
        $$ = create_term_node(constant_false);
    }
    | "string" {
        $$ = create_term_node(term_operation_t::variable);
        $$->variable = std::move(*$1);
        // the string is allocated from the
        // tokenizer and we need to free it
        free_lexer_string($1); 
    }
    | '(' term '*' term ')' {
        $$ = create_term_node(intersection, $2, $4);
    }
    | term '*' term {
        $$ = create_term_node(intersection, $1, $3);
    }
    | '(' term '+' term ')' {
        $$ = create_term_node(union_, $2, $4);
    }
    | term '+' term {
        $$ = create_term_node(union_, $1, $3);
    }
    | '-' term {
        $$ = create_term_node(complement, $2);
    }
    | '(' term ')' {
        $$ = $2;
    }
  ;
		\end{lstlisting}

		\subsubsection*{Abstract Syntax Tree}
			The visitor pattern is used to modify the formula, namely it's AST tree.
			
			The visitor pattern uses double virtual dispatching.

			\subsubsection*{Operation types in the formula/term nodes}
				\begin{lstlisting}
enum class formula_operation_t
{
    constant_true,
    constant_false,
    conjunction,
    disjunction,
    negation,
    implication,
    equality,
    contact,
    less_eq,
    measured_less_eq,
    eq_zero
};

enum class term_operation_t
{
    constant_true,
    constant_false,
    union_, // union is a keyword
    intersection,
    complement,
    variable
};

class Node
{
public:
    virtual void accept(Visitor& v) = 0;
};

class NFormula : public Node
{
public:
    NFormula(formula_operation_t op, Node* left = nullptr, Node* right = nullptr);

    void accept(Visitor& v) override { v.visit(*this); }

    formula_operation_t op;
    Node* left;
    Node* right;
};

class NTerm : public Node
{
public:
    NTerm(term_operation_t op, NTerm* left = nullptr, NTerm* right = nullptr);

    void accept(Visitor& v) override { v.visit(*this); }

    term_operation_t op;
    NTerm* left;
    NTerm* right;
    std::string variable;
};
				\end{lstlisting}
	
			\subsubsection*{Visitor Structure}
				\begin{lstlisting}
class Visitor
{
public:
    virtual void visit(NFormula& f) = 0;
    virtual void visit(NTerm& t) = 0;
};

class VPrinter : public Visitor
{
public:
    void visit(NFormula& f) override 
    {
	  // Here it prints the formula node information 
    }

    void visit(NTerm& t) override 
    { 
         // Here it prints the term node information 
    }
};
				\end{lstlisting}

				The visitor pattern gives us the ability to add new visitors in a very simple manner.
				The new visitor should override the two visit methods and do whatever it wants with the ast nodes.

				%intro on why are we doing all those modifications to the formula's AST

			\subsubsection*{Visitors Implementation}
				\subsubsection*{VReduceConstants}
					Removes all unnecessary childs of And/Or/Negation operations of the following type:

					\begin{table}[H]
					  \centering
					  \begin{tabular}{llll}
					    \toprule
					    \midrule
					\tabitem -T $\equiv$ F & \tabitem C(0,0)  $\equiv$ F & \tabitem -F $\equiv$ T & \tabitem C(1,1) $\equiv$ T \\
					\tabitem (T \& T) $\equiv$ T & \tabitem C(a,0)  $\equiv$ F & \tabitem (F | F) $\equiv$ F & \tabitem C(0,a) $\equiv$ F \\
					\tabitem (g \& T) $\equiv$ g & \tabitem -1 $\equiv$ 0 & \tabitem (g | T) $\equiv$ T & \tabitem -0 $\equiv$ 1 \\
					\tabitem (T \& g) $\equiv$ g & \tabitem (1 * 1) $\equiv$ 1 & \tabitem (T | g) $\equiv$ T & \tabitem (0 + 0) $\equiv$ 0 \\
					\tabitem (g \& F) $\equiv$ F & \tabitem (t * 1) $\equiv$ t & \tabitem (g | F) $\equiv$ g & \tabitem (t + 1) $\equiv$ 1 \\
					\tabitem (F \& g) $\equiv$ F & \tabitem (1 * t) $\equiv$ t & \tabitem (F | g) $\equiv$ g & \tabitem (1 + t) $\equiv$ 1 \\
					\tabitem 0=0 $\equiv$ T & \tabitem (t * 0) $\equiv$ 0 & \tabitem 1=0 $\equiv$ F & \tabitem (t + 0) $\equiv$ t \\
					\tabitem <=(0,a) $\equiv$ T & \tabitem (0 * t) $\equiv$ 0 & \tabitem <=(a,1) $\equiv$ T & \tabitem (0 + t) $\equiv$ t \\

					    \bottomrule
					  \end{tabular}
					\end{table}
				\subsubsection*{VConvertContactsWithConstantTerms}
					Converts contacts with constant 1 terms in !=0 atomic formulas. 
					This visitor is best used after the contacts are reduced, via VReduceConstants
					\begin{itemize}
						\item C(a,1) $\equiv$ ~(a=0)  
						\item C(1,a) $\equiv$ ~(a=0)
					\end{itemize}
				\subsubsection*{VConvertLessEqContactWithEqualTerms}
					Converts contacts and <= atomic formulas with same terms:
					\begin{itemize}
						\item <=(a,a) $\equiv$ T, \\
							since (a * -a = 0))
						\item C(a,a) $\equiv$ ~(a=0)
					\end{itemize}
				\subsubsection*{VReduceDoubleNegation}
					Removes the double/tripple/etc negations. 
					This visitor is best used after all visitors which might add additional negations!
					\begin{itemize}
						\item --g $\equiv$ g
						\item --t $\equiv$ t
					\end{itemize}
				\subsubsection{VConvertImplicationEqualityToConjDisj}
					Converts all formula nodes of type implication and equality to nodes 
					which are using just conjuction and disjunction. 
					Main reason for that is to simplify the tableau method - 
					to work only with conjunctions and disjunctions.
					\begin{itemize}
						\item (f -> g)  $\equiv$ (~f | g)
						\item (f <-> g) $\equiv$ ((f \& g) | (~f \& ~g))
					\end{itemize}
				\subsubsection*{VConvertLessEqToEqZero}
					Converts the less equal atomic formula to an equals to zero atomic formula
					\begin{itemize}
						\item <=(a,b) $\equiv$ (a * -b) = 0
					\end{itemize}
				\subsubsection*{VSplitDisjInLessEqAndContacts}
					Converts the less equal atomic formula to an equals to zero atomic formula
					\begin{itemize}
						\item C(a + b, c) $\equiv$ C(a,c) | C(b,c)
						\item <=(a + b, c) $\equiv$ <=(a,c) \& <=(b,c)
					\end{itemize}

				There are few visitors which only collect or print information from the formula
					\begin{itemize}
						\item VVariablesGetter - gets all variables from the formula (as string)
						\item VPrinter - prints the formula to some provided output stream
					\end{itemize}

	\section{Formula Structure}
		The formula structure is similar to the AST structure, but with restricted formula operations and additional information.
		% intro that the formula is built recursively 
		There are 2 types of nodes: 
			\begin{itemize}
				\item formula
				\item term
			\end{itemize}
		Every member variable in the nodes is caluclated in building, 
		this way getting the hash code of a node is done in constant time.

		\subsection*{Formula Node Structure}
		\begin{lstlisting}
class formula
{
public:
    enum class operation_type : char
    {
        constant_true,
        constant_false,
        conjunction,
        disjunction,
        negation,
        measured_less_eq,
        eq_zero,
        c
    };

    operation_type op_;
    formula_mgr* formula_mgr_;
    std::size_t hash_;

    // For simplicity raw pointers and union, 
    // a better solution would be unique pointers and variants
    struct child_formulas
    {
        formula* left;
        formula* right;
    };
    struct child_terms
    {
        term* left;
        term* right;
    };
    union {
        child_formulas child_f_;
        child_terms child_t_;
    };

    auto build(const NFormula& f) -> bool;

    auto operator==(const formula& rhs) const -> bool;
    auto operator!=(const formula& rhs) const -> bool;

    // Evalates the formula but ignores all measured less or equal 
    // atomic formulas, as if there were not existing
    auto evaluate(const variable_id_to_points_t& evals,
		const contacts_t& contact_relations) const -> bool;
};
		\end{lstlisting}
	
		\subsection*{Term Node Structure}
		\begin{lstlisting}
class term
{
public:
    enum class operation_type : char
    {
        constant_true,
        constant_false,
        union_,
        intersection,
        complement,
        variable
    };

    operation_type op_;

    // Used to make a bitmask for the used variables in the 
    // term(w.r.t all variables in the whole formula) and to print the
    // term with it's variable names instead of their (optimized) IDs.
    const formula_mgr* formula_mgr_; 
    variables_mask_t variables_; // All used variables in the term.

    // For simplicity raw pointers and union, 
    // a better solution would be unique pointers and variants
    struct childs
    {
        term* left;
        term* right;
    };
    union {
        childs childs_;
        size_t variable_id_;
    };

    std::size_t hash_;

    auto build(const NTerm& t) -> bool;

    auto operator==(const term& rhs) const -> bool;
    auto operator!=(const term& rhs) const -> bool;

    auto evaluate(const variable_id_to_points_t& variable_evaluations, 
    	const size_t points_count) const -> model_points_set_t;

    // Evaluates the term with the provided variables evaluations but if
    // some of the used variables in the term do not have evaluations
    // it creates a smaller subterm with the unknown variables.
    // Note that it reduces the term's constants, e.g. '1 + X' -> '1'
    // and does not look at the X's evaluation at all.
    // With the latest algorithms, this is not used.
    auto evaluate(const variables_evaluations_block& evaluation_block, 
	bool skip_subterm_creation = false) const -> evaluation_result;
};
		\end{lstlisting}
	

	\subsection{Building a formula node}  % Add more information on how the formula is built.
		The building of the formula structure is trivial, namely based on the AST node's operation types.
		Few important specifications of a node 
		\begin{itemize}
			\item hash code
			\item variable mask for all used variables in the term(and it's child terms)
		\end{itemize}

		\subsubsection*{Node's hash code}
			The hash code of a node is mainly used to compare if two nodes are equal. 
			This comparison is used in all maps and sets where the key is a node. 
			
			If for two formulas/terms nodes, their hash codes are same, then the content of the nodes is 
			compared in order to verify that they are the same formulas/terms.
			\newline
			The contact operatior requires a special check since the commutativity of Contacts is supported.
			\newline
			% for this we should have an additional definition.

			Let a, b be two terms, then
			\begin{equation}
				C(a, b) = C(b, a)
			\end{equation}
			therefore the check for equality will be done twice instead of once, namely
			\begin{equation}
				 C(a, b) = C(c, d) \rightarrow (a = c \wedge b = d) \vee (a = d \wedge b = c).
			\end{equation}
		
		\subsubsection{Formula Refiners}
			The formula refiners are an optional parameter when building a formula node.
			They are a set of optional filters which may optimize the formula by reducing redundant parts of the 
			formula or by transforming some nodes in a way that they will be easier to be evaluated later on.
			
			Most important formula refiners:
			\begin{itemize}
				\item Convert Contacts and less or equal atomic formas which have same terms
				\item Convert disjunction in contacts and less or equal atomic formulas
				\item Reduce constants
				\item Reduce contacts with constants
				\item Remove double negation
			\end{itemize}

			These formula refiners are done when the formula is built, meaning that after the 
			AST tree is constructed each of these refiners enables or disabled a visitor. 
			The formula refiners are mapped in a one to one manner to a subset of all the visitors defined 
			in \#REF visitor.

			\begin{itemize}
				\item Convert Contacts and less or equal atomic formas which have same terms \\
					 is mapped to VConvertLessEqContactWithEqualTerms
				\item Convert disjunction in contacts and less or equal atomic formulas \\
					 is mapped to VSplitDisjInLessEqAndContacts
				\item Reduce constants \\
					 is mapped to VReduceConstants
				\item Reduce contacts with constants \\
					 is mapped to VConvertContactsWithConstantTerms
				\item Remove double negation \\
					 is mapped to VReduceDoubleNegation
			\end{itemize}
						
		\subsubsection*{Implementation}
			The formula refiners are just a flag denoting if a formula refiner should be applied.
			\begin{lstlisting}
enum class formula_refiners : int32_t
{
    none                                    = 0,
    convert_contact_less_eq_with_same_terms = 1 << 1,
    convert_disjunction_in_contact_less_eq  = 1 << 2,
    reduce_constants                        = 1 << 3,
    reduce_contacts_with_constants          = 1 << 4,
    remove_double_negation                  = 1 << 5,
    all = convert_contact_less_eq_with_same_terms
        | convert_disjunction_in_contact_less_eq 
        | reduce_constants 
        | reduce_contacts_with_constants 
        | remove_double_negation
};
			\end{lstlisting}

			\begin{lstlisting}
auto formula_mgr::build(const std::string& f, 
	const formula_refiners& refiners_flags) -> bool
{
    // Parsing the formula
    parser_error_info error_info;
    auto formula_AST = parse_from_input_string(f.c_str(), error_info);
    if(!formula_AST)
    {
        std::stringstream error_msg;
        error_info.printer(f, error_msg);
        info() << "\n" << error_msg.str();
        return false;
    }

    std::stringstream info_buff;
    info_buff << "Parsed formula: ";
    VPrinter printer(info_buff);
    formula_AST->accept(printer);
    info_buff << "\n";

    VConvertImplicationEqualityToConjDisj convertor;
    formula_AST->accept(convertor);
    info_buff << "Converted (-> <->)        : ";
    formula_AST->accept(printer);

    // NOTE: Consider making VSplitDisjInLessEqAndContacts 
    // and VSplitDisjInLessEqAndContacts combined because in some 
    // intermediate splitting the two terms might match.
    // Nevertheless, this will still be not 100\% sufficient because 
    // the order of spliting might take a big role and skip 
    // some pontential matches. 
    // For not just convert them after the splitting. 
    // It's just a small optimization.
    if(has_flag(refiners_flags, 
	formula_refiners::convert_contact_less_eq_with_same_terms))
    {
        VConvertLessEqContactWithEqualTerms 
		convertor_lessEq_contact_with_equal_terms;
        formula_AST->accept(convertor_lessEq_contact_with_equal_terms);
        info_buff << "Converted C(a,a);<=(a,a)  : ";
        formula_AST->accept(printer);
    }

    if(has_flag(refiners_flags, 
	formula_refiners::convert_disjunction_in_contact_less_eq))
    {
        VSplitDisjInLessEqAndContacts disj_in_contact_splitter;
        formula_AST->accept(disj_in_contact_splitter);
        info_buff << "C(a+b,c)->C(a,c)|C(b,c) ;\n";
        info_buff << "<=(a+b,c)-><=(a,c)&<=(b,c): ";
        formula_AST->accept(printer);
    }

    if(has_flag(refiners_flags, 
	formula_refiners::convert_contact_less_eq_with_same_terms))
    {
        VConvertLessEqContactWithEqualTerms 
		convertor_lessEq_contact_with_equal_terms;
        formula_AST->accept(convertor_lessEq_contact_with_equal_terms);
        info_buff << "Converted C(a,a);<=(a,a)  : ";
        formula_AST->accept(printer);
    }

    VConvertLessEqToEqZero eq_zero_convertor;
    formula_AST->accept(eq_zero_convertor);
    info_buff << "Converted (<= =0) formula : ";
    formula_AST->accept(printer);

    if(has_flag(refiners_flags, 
	formula_refiners::reduce_constants))
    {
        VReduceConstants trivial_reducer;
        formula_AST->accept(trivial_reducer);
        info_buff << "Reduced constants         : ";
        formula_AST->accept(printer);
    }

    if(has_flag(refiners_flags, 
	formula_refiners::reduce_contacts_with_constants))
    {
        VConvertContactsWithConstantTerms 
		contacts_with_constant_as_term_convertor;
        formula_AST->accept(contacts_with_constant_as_term_convertor);
        info_buff << "Converted C(a,1)->~(a=0)  : ";
        formula_AST->accept(printer);
    }

    if(has_flag(refiners_flags, 
	formula_refiners::remove_double_negation))
    {
        VReduceDoubleNegation double_negation_reducer;
        formula_AST->accept(double_negation_reducer);
        info_buff << "Reduced double negation   : ";
        formula_AST->accept(printer);
    }

    info() << info_buff.str();

    // Will cash all variables and when building the formula 
    // tree we will use their ids instead of the heavy strings
    VVariablesGetter::variables_set_t variables;
    VVariablesGetter variables_getter(variables);
    formula_AST->accept(variables_getter);

    variables_.reserve(variables.size());
    variable_to_id_.reserve(variables.size());
    for(const auto& variable : variables)
    {
        variable_to_id_[variable] = variables_.size();
        variables_.emplace_back(variable);
    }

    // The building of the formula from it's AST
    return f_.build(*formula_AST); 
}
			\end{lstlisting}

	\subsubsection*{Node evaluation}
		% this should be explained very well, and not just here but with multilpe definitions on theory level



	\section{Tableaux}
	The Tableaux process is decision procedure, which recursively breaks down a given formula into basic components 
	based on which a decision can be concluded. The recursive step which breaks down a formula creates one or two 
	new formulas, which in terms of their structure are simpler then the initial formula. Since the recursive step can create
	at most two new formulas, this means the recursive step will create at most two branches or a binary tree, where the nodes
	are the formulas and the links represent the recursive step. The different branches are considered to be disjuncted while
   	nodes of the same branch are considered in conjunction. The procedure modifies the tableau in such a way that the 
	formula represented by the resulting tableau is equivalent to the original one.

	Contradiction may arise when in the same branch, on some step there exists a formula and the negation of the same formula.
	If in some branch there exists a contradiction, then that branch closes. If all branches close then the proof is complete.
	
	The main principle of the tableaux is to break complex formulae into smaller ones until complementary pairs of literals are
	produced or no further expansion is possible.

	\subsection{Definition: Tableaux Step}
		The Tableaux Step takes as input a formula and a set of accumulated formulae and produces as 
		output one or two new formulae, depending on the operation. 
		The set of accumulated formulae consist of the broken down formulae by previous tableaux steps.
		The output of the tableaux step depends on the rule applied to the formula.

		\subsubsection*{Definition: Marked Formula} 
			Let $\varphi$ be a formula, then $\varphi$ might be marked as:
			\begin{itemize}
				\item true, we will write $\mathbb{T}\varphi$
				\item false, we will write $\mathbb{F}\varphi$
			\end{itemize}

		\subsubsection*{Definition: Accumulated Formulae}
			The accumulated formulae set consists only of marked formulae and the letter X will be usually used for its representation.

		\subsubsection{Rules}
		\subsubsection*{Negation}
			$\begin{array}{rl}
				& \mathbb{T}(\neg \varphi), X \\
			      \cline{2-2}
			      & \mathbb{F}(\varphi), X
			\end{array}$
			\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
			$\begin{array}{rl}
				& \mathbb{F}(\neg \varphi), X \\
			      \cline{2-2}
			      & \mathbb{T}(\varphi), X
			\end{array}$

		\subsubsection*{And}
			$\begin{array}{rl}
				& \mathbb{T}(\varphi \: \wedge \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, \mathbb{T}\psi, X
			\end{array}$
			\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
			$\begin{array}{rl}
				& \:\:\: \mathbb{F}(\varphi \: \wedge \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{F}\varphi, X \:\:\:\:\:\:\:\: \mathbb{F}\psi, X
			\end{array}$

		\subsubsection*{Or}
			$\begin{array}{rl}
				& \:\:\: \mathbb{T}(\varphi \: \vee \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, X \:\:\:\:\:\:\:\: \mathbb{T}\psi, X
			\end{array}$
			\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
			$\begin{array}{rl}
				& \mathbb{F}(\varphi \: \vee \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{F}\varphi, \mathbb{F}\psi, X
			\end{array}$

		\subsubsection*{Implication}
			$\begin{array}{rl}
				& \:\:\: \mathbb{T}(\varphi \: \rightarrow \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{F}\varphi, X \:\:\:\:\:\:\:\: \mathbb{T}\psi, X
			\end{array}$
			\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
			$\begin{array}{rl}
				& \mathbb{F}(\varphi \: \rightarrow \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, \mathbb{F}\psi, X
			\end{array}$

		\subsubsection*{Equivalence}
			$\begin{array}{rl}
				& \:\:\:\:\:\:\:\: \mathbb{T}(\varphi \: \leftrightarrow \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, \mathbb{T}\psi, X \:\:\:\:\:\:\:\: \mathbb{F}\varphi, \mathbb{F}\psi, X
			\end{array}$
			\:\:\:\:\:\:\:\:\:\:
			$\begin{array}{rl}
				& \:\:\:\:\:\:\:\: \mathbb{F}(\varphi \: \leftrightarrow \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, \mathbb{F}\psi, X \:\:\:\:\:\:\:\: \mathbb{F}\varphi, \mathbb{T}\psi, X
			\end{array}$
		\newline
		\newline
		\newline
		The final output of the Tableaux process is "False" when all branches are closed or a set of atomic formulae, when there exists a branch which is not closed.
		\newline
	
		For our usecases the functionality of the tableaux process shall be extended to achive better results, since if the branch is not closed, there are 
		additional calculations needed in order to verify that there is no contradiction, namely to verify that there is no contradiction on Term level.
		This verification can be done in different manners, depending on the algorithm type. The best way to think about it is to have the tableaux process
		return a list, where each element is the set of atomic formulae found in a specific branch. This way the atomic formulae for each branch are produced, and 
		afterwards can be used in different algorithms. This is just an example, a way of thinking about the problem the real implementation is much more space 
		efficient.

	\subsection{Tableaux implementation}
		The programming implementation of the tableaux method follows the standard tableaux process explaned above.

		First interesting design decision is to keep all true formulae in one data set, and all false formulae in another data set.
		This enables fast searches wheter a formula has been marked as true or false.
		
		\subsubsection*{Definition: Marked Formula Collection}
			Let X be a set of formulae, then X is called marked formula collection if and only if all formulae in X are marked as true 
			or all formulae are marked as false.

			This collection is implemented with unordered\_map (hashmap),
			which stores the formulae by pointers to them, uses their precalculated hash and operator== to compare them.
			The average complexity for search, insert and erase in this collection is O(1).
		\newline
		\newline
		There exist 8 important marked formula collections:
%Note add definition for positive and negative collections !!!
		\begin{itemize}
			\item formulas\_T\_ - contains only formulae marked as true
			\item formulas\_F\_ - contains only formulae marked as false, \\
				For example, if $\neg\varphi$ is encountered as an output of the tableaux step, then only $\varphi$ is inserted into the formula\_F\_
			\item contacts\_T\_ - contains only contacts formulae marked as true
			\item contacts\_F\_ - contains only contacts formulae marked as false
			\item zero\_terms\_T\_ - contains only formulae of type $\varphi \le \psi$ marked as true
			\item zero\_terms\_F\_ - contains only formulae of type $\varphi \le \psi$ marked as false
			\item measured\_less\_eq\_T\_ - contains only formulae of type $\varphi \le_m \psi$ marked as true
			\item measured\_less\_eq\_F\_ - contains only formulae of type $\varphi \le_m \psi$ marked as false
		\end{itemize}

		\subsubsection*{Definition: Formula Contradiction}
			Let $\varphi$ be a marked formula, then $\varphi$ is causing a contradiction if any of the followings is true:
			\begin{itemize}
				\item $\varphi$ is marked as true and $\varphi \in$ formulas\_F\_
				\item $\varphi$ is marked as false and $\varphi \in$ formulas\_T\_
				\item $\varphi$ is a contact formula marked as true and $\varphi \in$ contacts\_F\_
				\item $\varphi$ is a contact formula marked as false and $\varphi \in$ contacts\_T\_
				\item $\varphi$ is a zero terms formula marked as true and $\varphi \in$ zero\_terms\_F\_
				\item $\varphi$ is a zero terms formula marked as false and $\varphi \in$ zero\_terms\_T\_
				\item $\varphi$ is a measured less formula marked as true and $\varphi \in$ measured\_less\_eq\_F\_
				\item $\varphi$ is a measured less formula marked as false and $\varphi \in$ measured\_less\_eq\_T\_

			\end{itemize}

		\subsubsection*{Invariant}
			At any time, all formulae in all eight marked formula collections do not contradict.

			A contradiction may occure if a formula is split and some of the resulting components causes a contradiction.

		\subsubsection*{Example}
			Let's assume that contacts\_T\_ = \{ C(a, b)\} and let's have a look at the following formula $\mathbb{T}(T \wedge \neg C(a,b))$.

			By the rules of decomposition, namely the ( $\wedge$ ) rule will produce $\mathbb{T}T, \mathbb{T}\neg C(a,b)$. 

			Then the $\mathbb{T}\neg C(a,b)$ will be decomposed to $\mathbb{F} C(a,b)$ by the ( $\neg$ ) rule, which causes a contradiction
			since C(a,b) is already present in contacts\_T\_ formulae

		\subsubsection*{Tableaux Algorithm}
			Given a formula $\varphi$, the following algorithm determines final atomic formulae in all branches of the tableaux process.

			As a first step if the formula $\varphi$ is the constant F, then false is returned directly, otherwise the whole formula $\varphi$ is inserted in formulas\_T\_.
		\newline
			\subsubsection*{Remarks}
			\begin{itemize}
				\item true boolean value is used to represent the formula constant T
				\item false boolean value is used to represent the formula constant F
				\item The commutativity of the contacts: C(a,b) == C(b,a)
			\end{itemize}
			Few lemmas which will provide a much more efficient contradiction finding in the tableaux process.
			\subsubsection*{Lemma: A}
				Let x be a term, suppose that the atomic formula x = 0 has already been marked as true,
				then marking the following formulae as true will lead to contradiction:
				\begin{itemize}
					\item C(x,y)
					\item C(y,x)
				\end{itemize}
				for some arbitrary term y.

			\subsubsection*{Lemma: A-inverse}
				Let x, y and z be terms, suppose that the atomic formulae C(x,y) or C(z, x) has already been marked as true,
				then marking the formula x = 0 as true will lead to contradiction.
				
			\subsubsection*{Lemma: Complexity A and A-inverse} 
				The algorithmic complexity to check whether a new formula leads to contradiction by Lemma A and Lemma A-inverse is done
				effectively, namely in constant time with the usage of one new collection contact\_T\_terms\_ which keeps the terms of 
				the true contacts, namely the contacts in in the collection contacts\_T\_. This means that for each $\mathbb{T}(C(x, y))$, the 
				terms x and y are in the mentioned collection of true terms. The contact\_T\_terms\_  is a multiset and keeps track 
				of all added terms, meaning that if the term x is added twice and then removed only once there will still be an entry of 
				that x in the contact\_T\_terms\_ collection.
				
				To check if a new formula leads to contradiction by Lemma A or Lemma A-inverse the following method is used:
				\begin{lstlisting}
auto has_broken_contact_rule(const formula* f) const -> bool;
				\end{lstlisting}

			\subsubsection{Handy methods}
			\subsubsection*{Find formula}
			\subsubsection*{Find formula marked as true}
				\begin{lstlisting}
auto find_in_T(const formula* f) const -> bool
				\end{lstlisting}
				Checks if the formula $\varphi$ exists in any positive collection depending on the type of $\varphi$, namely
				if $\varphi$ is of type:
				\begin{itemize}
					\item C(x, y), then return true $\iff \varphi \in contacts\_T\_$
					\item $x \le y$, then return true $\iff \varphi \in zero_terms\_T\_$
					\item $x \le_m y$, then return true $\iff \varphi \in measured_less_eq\_T\_$
					\item $\neg \psi$, then return true $\iff \varphi \in formulas\_T\_$
					\item $\psi_1 \sigma \psi_2$, where $\sigma \in \{\wedge, \vee\}$, then return true $\iff \varphi \in formulas\_T\_$
				\end{itemize}
			\subsubsection*{Find formula marked as false}
				\begin{lstlisting}
auto find_in_F(const formula* f) const -> bool
				\end{lstlisting}
				Checks if the formula $\varphi$ exists in any negative collection depending on the type of $\varphi$, namely
				if $\varphi$ is of type:
				\begin{itemize}
					\item C(x, y), then return true $\iff \varphi \in contacts\_F\_$
					\item $x \le y$, then return true $\iff \varphi \in zero_terms\_F\_$
					\item $x \le_m y$, then return true $\iff \varphi \in measured_less_eq\_F\_$
					\item $\neg \psi$, then return true $\iff \varphi \in formulas\_F\_$
					\item $\psi_1 \sigma \psi_2$, where $\sigma \in \{\wedge, \vee\}$, then return true $\iff \varphi \in formulas\_F\_$
				\end{itemize}
			\subsubsection*{Add formula}
			\subsubsection*{Mark formula as true}
				\begin{lstlisting}
void add_formula_to_T(const formula* f)
				\end{lstlisting}
				Adds the formula $\varphi$ as true in in the respective positive collection, namely
				if $\varphi$ is of type:
				\begin{itemize}
					\item C(x, y), then $\varphi$ is added to contacts\_T\_, and the terms x and y are added to the contact\_T\_terms\_ collection.
					\item $x = 0$, then x is added in zero\_terms\_T\_
					\item $x \le_m y$, then $\varphi$ is added to measured\_less\_eq\_T\_
					\item $\neg \psi$, then $\varphi$ is added to formulas\_T\_
					\item $\psi_1 \sigma \psi_2$, where $\sigma \in \{\wedge, \vee\}$, then $\varphi$ is added to formulas\_T\_
				\end{itemize}
			\subsubsection*{Mark formula as false}
				\begin{lstlisting}
void add_formula_to_F(const formula* f)
				\end{lstlisting}
				Adds the formula $\varphi$ as false in in the respective negative collection, namely
				if $\varphi$ is of type:
				\begin{itemize}
					\item C(x, y), then $\varphi$ is added to contacts\_F\_.
					\item $x = 0$, then x is added in zero\_terms\_F\_
					\item $x \le_m y$, then $\varphi$ is added to measured\_less\_eq\_F\_
					\item $\neg \psi$, then $\varphi$ is added to formulas\_F\_
					\item $\psi_1 \sigma \psi_2$, where $\sigma \in \{\wedge, \vee\}$, then $\varphi$ is added to formulas\_F\_
				\end{itemize}
			\subsubsection*{Remove formula}
			\subsubsection*{Remove formula marked as true}
				\begin{lstlisting}
void remove_formula_from_T(const formula* f)
				\end{lstlisting}
				Removes the formula $\varphi$ from the respective positive collection, namely
				if $\varphi$ is of type:
				\begin{itemize}
					\item C(x, y), then $\varphi$ is removed from contacts\_T\_, and the terms x and y are removed from the contact\_T\_terms\_ collection.
					\item $x = 0$, then x is removed from zero\_terms\_T\_
					\item $x \le_m y$, then $\varphi$ is removed from measured\_less\_eq\_T\_
					\item $\neg \psi$, then $\varphi$ is removed from formulas\_T\_
					\item $\psi_1 \sigma \psi_2$, where $\sigma \in \{\wedge, \vee\}$, then $\varphi$ is removed from formulas\_T\_
				\end{itemize}
			\subsubsection*{Remove formula marked as true}
				\begin{lstlisting}
void remove_formula_from_F(const formula* f)
				\end{lstlisting}
				Removes the formula $\varphi$ from the respective negative collection, namely
				if $\varphi$ is of type:
				\begin{itemize}
					\item C(x, y), then $\varphi$ is removed from contacts\_F\_
					\item $x = 0$, then x is removed from zero\_terms\_F\_
					\item $x \le_m y$, then $\varphi$ is removed from measured\_less\_eq\_F\_
					\item $\neg \psi$, then $\varphi$ is removed from formulas\_F\_
					\item $\psi_1 \sigma \psi_2$, where $\sigma \in \{\wedge, \vee\}$, then $\varphi$ is removed from formulas\_F\_
				\end{itemize}
			\subsubsection{Def: Tableaux branch output}
				As stated above the ouput of a branch in the tableaux process is a set of atomic formulas.
				These atomic formulas can be grouped in four groups:
				\begin{itemize}
					\item Contacts
					\item Non Contacts
					\item Equal to Zero Terms
					\item Not Equal to Zero Terms
				\end{itemize}
				These four groups can be represented with the following formula:
				\begin{equation}
					\bigwedge\nolimits_{i} \; C(a_i, b_i) \:\: \wedge \:\:
					\bigwedge\nolimits_{j} \; \neg C(e_j, f_j) \:\: \wedge \:\:
					\bigwedge\nolimits_{k} \; d_k = 0 \:\: \wedge \:\:
					\bigwedge\nolimits_{l} \; g_l \neq 0 
				\end{equation}
				% TODO explain which is what
			\subsubsection*{Tableaux Satisfiable Step Implementation}
				\begin{lstlisting}
auto tableau::satisfiable_step() -> bool
{
    // The bottom of the recursive algorithm is when we have 
    // only atomic formulas(which does not contradicts). 
    // Then we can run algorithms for model construction.
    if(formulas_T_.empty() && formulas_F_.empty())
    {
        return has_satisfiable_model();
    }

    if(!formulas_T_.empty())
    {
        // Choosing some formula to handle in this step.
        // If this branch does not produce a valid satisfiable path,
	 // then this formula will be returned to formulas_T_
        auto f = *formulas_T_.begin();

        const auto op = f->get_operation_type();
        if(op == op_t::negation)
        {
            // T(~X) -> F(X)
            auto X = f->get_left_child_formula();
            if(X->is_constant())
            {
                // F(T) is not satisfiable
                if(X->is_constant_true())
                {
                    return false;
                }
		// F(F) is satisfiable, continue with the rest
                return satisfiable_step(); 
            }

            if(find_in_T(X))
            {
		// contradiction, we want to satisfy F(X) 
		// but we already have to satisfy T(X)
                return false;
            }

            if(find_in_F(X)) // skip adding it multiple times
            {
                return satisfiable_step();
            }

            add_formula_to_F(X);
            auto res = satisfiable_step();
            remove_formula_from_F(X);
            return res;
        }

        if(op == op_t::conjunction)
        {
            // T(X & Y) -> T(X) & T(Y)
            T_conjuction_child X(*this, f->get_left_child_formula());
            T_conjuction_child Y(*this, f->get_right_child_formula());
		
	    // Checks if X breaks the contact rule 
            // or brings a contradiction
            if(!X.validate()) 
            {
                return false;
            }
            X.add_to_T(); // Adds X to T collection

            if(!Y.validate())
            {
                X.remove_from_T();
                return false;
            }
            Y.add_to_T();

            auto res = satisfiable_step();
            X.remove_from_T();
            Y.remove_from_T();

            return res;
        }

        assert(op == op_t::disjunction);

        // T(X v Y) -> T(X) v T(Y)
        auto X = f->get_left_child_formula();
        auto Y = f->get_right_child_formula();
        trace() << "Will split to two subtrees: " 
		<< *X << " and " << *Y;

        // T(T) is satisfiable and we can skip the other branch
        if(X->is_constant_true() || Y->is_constant_true())
        {
            trace() << "One of the childs is constant true";
            return satisfiable_step();
        }

        auto process_T_disj_child = [&](const formula* child) {
            if(child->is_constant_false() || // T(F) is not satisfiable
               find_in_F(child) || has_broken_contact_rule(child))
            {
                return false;
            }

            if(find_in_T(child)) // skip adding it multiple times
            {
                return satisfiable_step();
            }

            add_formula_to_T(child);
            const auto res = satisfiable_step();
            remove_formula_from_T(child);
            return res;
        };

        trace() << "Start of the left subtree: " << *X << " of " << *f;
        if(process_T_disj_child(X))
        {
            return true; // there was no contradiction in the left path, 
			 // so there is no need to continue with
                         // the right path
        }

        trace() << "Start of the right subtree: " << *Y << " of " << *f;
        return process_T_disj_child(Y);
    }

    // Almost analogous but taking a formula from Fs

    // Choosing some formula to handle in this step.
    // If this branch does not produce a valid satisfiable path,
    // then this formula will be returned to formulas_F_
    auto f = *formulas_F_.begin();

    const auto op = f->get_operation_type();
    if(op == op_t::negation)
    {
        // F(~X) -> T(X)
        auto X = f->get_left_child_formula();
        if(X->is_constant())
        {
            // T(F) is not satisfiable
            if(X->is_constant_false())
            {
                return false;
            }
		// T(T) is satisfiable, continue with the rest
            return satisfiable_step(); 
        }
        if(find_in_F(X)) 
        {
		// contradiction, we want to satisfy T(X)
		// but we already have to satisfy F(X)
            return false;
        }
	  // We will add T(X) where X might be Contact or =0 term,
        // so we need to verify that we will not break the contact rule
        if(has_broken_contact_rule(X)) 
        {
            return false;
        }

        if(find_in_T(X)) // skip adding it multiple times
        {
            return satisfiable_step();
        }

        add_formula_to_T(X);
        auto res = satisfiable_step();
        remove_formula_from_T(X);
        return res;
    }

    if(op == op_t::disjunction)
    {
        // F(X v Y) -> F(X) & F(Y)
        F_disjunction_child X(*this, f->get_left_child_formula());
        F_disjunction_child Y(*this, f->get_right_child_formula());

	// Checks that X does not bring a contradiction
        if(!X.validate()) 
        {
            return false;
        }
        X.add_to_F();

        if(!Y.validate())
        {
            X.remove_from_F();
            return false;
        }
        Y.add_to_F();

        auto res = satisfiable_step();

        X.remove_from_F();
        Y.remove_from_F();

        return res;
    }

    assert(op == op_t::conjunction);

    // F(X & Y) -> F(X) v F(Y)
    auto X = f->get_left_child_formula();
    auto Y = f->get_right_child_formula();

    trace() << "Will split to two subtrees: " << *X << " and " << *Y;

    // F(F) is satisfiable and we can skip the other branch
    if(X->is_constant_false() || Y->is_constant_false())
    {
        trace() << "One of the childs is constant false";
        return satisfiable_step();
    }

    auto process_F_conj_child = [&](const formula* child) {
        if(child->is_constant_true() || // F(T) is not satisfiable
           find_in_T(child))
        {
            return false;
        }
        if(find_in_F(child)) // skip adding it multiple times
        {
            return satisfiable_step();
        }

        add_formula_to_F(child);
        const auto res = satisfiable_step();
        remove_formula_from_F(child);
        return res;
    };

    trace() << "Start of the left subtree: " << *X << " of " << *f;
    if(process_F_conj_child(X))
    {
        return true; // there was no contradiction in left path,
			// so there is no need to continue with the
                     // right path
    }

    trace() << "Start of the right subtree: " << *Y << " of " << *f;
    return process_F_conj_child(Y);
}
				\end{lstlisting}
	\newpage


	\subsection{Formula Model}
		% What is a model ? 
		Every model type has at least two things in common:
		\begin{itemize}
			\item Adjacency matrix for the contacts between the points
			\item Vector of bitsets representing the value of v(p), namely the set of points which are in v(p)
		\end{itemize}

		All models also have similar collection of points each of which has an evaluation for all 
		used variables in the tableau's path (this evaluation identifies the point).
		\newline
		All models can be created(or at least tried to be created) via the marked formula collections and 
		some meta information for the whole formula, via the 'create' method.
		\begin{lstlisting}
virtual auto create(const formulas_t& contacts_T, 
	const formulas_t& contacts_F, 
	const terms_t& zero_terms_T,
	const terms_t& zero_terms_F, 
	const formulas_t& measured_less_eq_T, 
	const formulas_t& measured_less_eq_F, 
	const variables_mask_t& used_variables, 
	const formula_mgr* mgr)
    -> bool = 0;
		\end{lstlisting}

		\subsubsection*{Adjacency Matrix member variable}
			\begin{lstlisting}
/*
    Symetric square bit matrix. contacts_[i] gives a bit mask
    of all points which are in contact with the point 'i'.
    For example, let us have a model with 6 points:
        0---1  // contact between 0 and 1
        2---3  // contact between 2 and 3
        4      // point from !=0 term
        5      // point from !=0 term

    The bit matrix will be the following:
        \ 012345
        0 110000    // from 0---1 and reflexivity (0---0)
        1 110000    // from 1---0 and reflexivity (1---1)
        2 001100    // from 2---3 and reflexivity (2---2)
        3 001100    // from 3---2 and reflexivity (3---3)
        4 000010    // just reflexivity (4---4)
        5 000001    // just reflexivity (5---5)
*/
contacts_t contact_relations_;
			\end{lstlisting}

		\subsubsection*{Variable Evaluations member variable}
			\begin{lstlisting}
/*
    A vector of size the number of variables in the formula, 
    each element is a set of points, represented as a bitset.
    Keeps the variable evaluations, i.e. v(p).

    Model evaluation 'v' which for a given term returns 
    a subset of the model points.
    :
     - v(p) = { i | (i) (xxx...x)[p] == 1, i.e. in point 'i' 
        the evaluation of the variable 'p' is 1 }, where 'p'
        is a variable(for optimzations it's an id of the 
        string representation of that variable)
     - v(a * b) = v(a) & v(b)
     - v(a + b) = v(a) | v(b)
     - v(-a) = ~v(a)

    For example, let us have the following 
        formula: C(a * b, c) & c != 0 & -a != 0
    Then a model could be the following:
        (110) (a * b) 0---1 (c) (001)
        (011) (c)  2
        (000) (-a) 3
    Let assume that 'a' has a variable id 0, 
        'b' has id 1 and 'c' has id 2.
    The bit matrix will be the following:
        \ 0123     // variable ids (rows) \ model points (columns)
        0 1000     // v(a) = { 0 }, i.e. all points 
             which have evaluation with bit at positon 0 set to 1
        1 1010     // v(b) = { 0, 2 }, ... at position 1 ...
        2 0110     // v(c) = { 1, 2 }, ... at position 2 ...
*/
variable_id_to_points_t variable_evaluations_;
			\end{lstlisting}
		
	\section{Models}
		Intro on what the models are and when they are used.
	\subsection{Connectivity Model}
		% NOTE Intro on what the connectivity model really is !
		Let us have $\varphi$ in the format defined in REF 4. % for now this is formula 4 
		Let us define few constants which will ease the annotation:
		\begin{itemize}
			\item N - number of variables in the atomic formulas
			\item M - number of atomic formulas
			\item I - number of Contact atomic formulae
			\item J - number of Non Contact atomic formulae
			\item K - number of Not Equal to Zero atomic formulae
			\item L - number of Equal to Zero atomic formulae
		\end{itemize}
		1) Let $\mathbb{M}$ denote the model of all possible unique model points, where one model point corresponds to 
			one variable evaluation $P_i$. 
			\newline
			Since there are N variables, the number of unique model points is $2^N$.
			\newline

			1.1) Filter out the model points which interfere with the zero terms, 
			which means that if $P_i$ evaluates some term $G_l$ to constant true then $P_i$ is filtered out.
			\newline

			1.2) Filter out the model points which interfere with the Non contants, which mens that 
				If $P_i$ evaluates some terms $E_j$ and $F_j$ to true, then $P_i$ is filtered out.
			\newline

			NOTE: that if $P_i$ evaluates the term $\tau$ to constant true then the model 
			evaluation v($\tau$) contains the point $P_i$ (and vice versa).
			\newline
			\newline
		So far, the model $\mathbb{M}$ satisfies all Equal to Zero atomic formulas and 
		'half' of the Non Contacts (only the reflexivity of the points)
			\newline
			\newline		
		2) Verification is done for the Not Equal to Zero atomic formulas in $\mathbb{M}$, namely:
			\begin{equation}
				\text{If  } \exists k: v(D_k) \neq \empty \text{ , then there does not exist a connected model.}
			\end{equation}

		2.1) Verification is done for the Contact atomic formulas in $\mathbb{M}$, namely:
			\begin{equation}
				\text{If  } \exists i: v(A_i) \neq \empty \vee v(B_i) \neq \empty \text{, then there does not exist a connected model.}
			\end{equation}
			\newline
			\newline	
		So far, $O(2^N * N)$ bits of memory to hold all points and 
		their evaluations and $O(2^N * M)$ time to process them.
			\newline
			\newline	
		3) Let $\mathbb{C}$ be a bit matrix of size $2^N x 2^N$.
			\newline
			
			This matrix will be called connectivity matrix and will represent the connected points in $\mathbb{M}$.
			
			\begin{equation}
				\text{Model points i and j are in contanct if } \mathbb{C}[ i ][ j ] \text{ is set.}
			\end{equation}
			\begin{equation}
				\text{Let } \forall i, j \in \mathbb{N} : \mathbb{C}[ i ][ j ] = 1
			\end{equation}

			meaning that at its creation all points are in contact.
			\newline
	
			3.1) Remove all connections which interfere with Non Contact atomic formulas.
				\newline

				Note that the reflexivity has been satisfied in 1.
				\begin{align*}
					\forall a, b < 2^N, \forall j :& \\
						\text{if } P_a [E_j] = 1 \wedge P_b [F_j] = 1 &\vee P_a[F_j] = 1 \wedge P_b[E_j] = 1, \\
						\text{then } \mathbb{C}[a][b] = 0 &\text{ and } \mathbb{C}[b][a] = 0.
				\end{align*} 

			For this step $O(2^N * 2^N) = O(2^{2*N})$ bits of memory were used and 

			total of $O(2^N * 2^N * J)$ time complexity.
			\newline
			\newline	
		4) Check that all Contacts are still satisfied
			\begin{equation}
				\forall i, j \in \mathbb{N}: C(A_i, B_i) \text{ is satisfied}
			\end{equation}
			
			For each contact $C(A_i, B_i)$, evaluate $v(A_i)$ and $v(B_i)$, 
			then for each point in $v(A_i)$ check in the connectivity matrix $\mathbb{C}$
			if it is connected with some point of $v(B_i)$.
			This is done with one "bitwise \&" operation directly on the whole row in 
			the matrix and $v(B_i)$ (which is a bitset).
			\newline
			The complexity for this step is: $O(I * (H + L * G)$,where: 
			\begin{itemize}
				\item H is the complexity for evaluation some term, 
					it's at most the number of operations in the term, something small.
				\item L is the number of points in $v(A_i)$ which is at most $2^N$.
			       \item G is the complexity for "bit operator \&" which is $2^N/2^6$.
			\end{itemize}
		5) The previous step produces the maximal unique satisfiable model, wihch is a graph $\mathbb{G}$.
			If there exists a satisfiable connected subgraph in the $\mathbb{G}$, then this is the connected model.
			Finding all connected subgraphs has time complexity of $O(2^N + 2^N * 2^N)$.
			Checking if a subset of points satisfies the formula can be done in a similar fashion(as the one above).
			\newline
			Note that only the check for Not Equal to Zero and Contacts atomic formulas has to be done, 
			since when a point is removed the  Equal to Zero and Non Contacts atomic formulas can not be broken.
			\newline
			Let Y be the number of points in the subset, then at most $O(Y * Y * M)$ time complexity.
			Note that this must be done for ach connected subgraph and the subgraphs are not overlapping!
			Upper bound for Y is $2^N$, so the upper bound and on the time complexity is: 
			\begin{equation*}
				O(2^N * 2^N * M),
			\end{equation*}
			since 
			\begin{equation*}
				x * x * M + y * y * M <<< (x+y)*(x+y)*M
			\end{equation*}
			\newline
			\newline	
		Overall memory complexity: $O(2^N * 2^N)$ bits
		\newline
		Overall time complexity: $O(2^N * 2^N * M)$

\end{document}










































