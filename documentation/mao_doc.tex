\documentclass{article}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{systeme}
\usepackage{newtxtext}
\usepackage{newtxmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage{makecell}
\usepackage{booktabs}% http://ctan.org/pkg/booktabs
\usepackage{float}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{multicol}

\usetikzlibrary{arrows.meta}

\restylefloat{table}
\newcommand{\tabitem}{~~\llap{\textbullet}~~}

\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\title{Satisfiability Of Qualitative Contact Logics}
\date{2019-9-28}
\author{Martin Stoev}

\begin{document}
	\maketitle
	\newpage

	\tableofcontents

	\newpage

	\section{Tableaux Method}
Properties for a logical formula are best proven when the formula is decomposed into subformulas. Namely, the formula is defined in such a way that it can be described with a a structural recursive approach. The idea is to test a property only for some subformula and then to derive that property for the given formula.
Being able from a subformula to conclude properties for the formula itself leads to well structured and performant algorithms.

The Tableau method is a formal proof procedure and can be found in many variants. Formally, this procedure is used to refute the validity of formulas. Specifically, if a formula X is given and we want to prove that X is valid, then we construct a new formula that will represent the invalidity of X. This new formula is usually created with additional syntactic expressions. Proving that the newly created formula is not valid, it implies proof of the validity of X. The proofing process uses steps to break down the given formula into simpler formulas. If these steps are applied multiple times, the proof of the initial complex formula comes down to a proof using syntactic comparisons of basic formulas, where a basic formula is a formula which can not be decomposed further.

For our purposes, we will use a slightly different version of the method described above, namely with the help of the decomposition steps we will try to find a model with certain properties in which the given formula will not be valid.

		\subsection{Propositional logic tableau}
The tableau method for propositional logic comes down to defining the decomposition of the propositional logic operations $\{ \neg, \vee, \wedge, \rightarrow, \leftrightarrow \}$. To reach this goal we need to improve our syntactical arsenal, namely to add the ability for asserting the validity of a formula. In order to do this we shall introduce two signs. These signs when combined with a formula will assert whether the formula is true or false. Formally, the two signs are \{ T, F \}. Let $\varphi$ be a formula, then
\begin{itemize}
	\item T$\varphi$ - asserts the validity of the formula $\varphi$
	\item F$\varphi$ - asserts the invalidity of the formula $\varphi$
\end{itemize} 

The tableau of a formula $\varphi$ begins with F$\varphi$. The intuition behind it is that we start with an assertion that $\varphi$ is not valid in some model, and by decomposing the formula during the tableau process we seek for contradictions in the subformals. If such contradiction exists then the initial guess that the formula is not valid is not true meaning that the formula is valid. On the other hand if a contradiction does not exist then the formula is not valid, additionaly a model can be constructed in which the formula $\varphi$ is not valid.

The decomposition process is a set of tableau steps, which decompose the initial formula into basic formulas. A tableau step applies one of the tableau rules to slightly simplify the given formula. There are two rules for each operation in the logic. In the case of propositional logic with the following operations $\{ \neg, \vee, \wedge, \rightarrow, \leftrightarrow \}$ there are ten rules. Each rule decomposes the formula in at most two subformulas which depends on the arity of the operation. The decompositioning process forms a branch. A branch contains all signed subformulas which have been asserted in the decompositioning process.

A tableau rule which decomposes the formula in two subformulas may require the assertion of only one of the subformulas to be satisfied. In this case we will say that the branch is split into two branches. However in some terminologies this is noted as a new branch spawned from the original branch, or that two new branches are created . For the sake of simplicity we will use the terminology of branch splitting. In a scenario where the branch is split all asserted formulas in the branch are copied in the splitted branch together with the newly asserted subformula from the tableau rule.The newly asserted subformulas depend on the tableau rule.

	\subsubsection{Rules}
		\paragraph{Negation}
The rules for negations are straightforward. When a negation operation is encountered the sign of the captured formula changes.
		\newline
		\noindent\begin{minipage}{.5\linewidth}
		\begin{align*}
			\begin{array}{rl}
				& \mathbb{T}(\neg \varphi), X \\
				      \cline{2-2}
				      & \mathbb{F}(\varphi), X
			\end{array}
		\end{align*}
		\end{minipage}%
		\begin{minipage}{.5\linewidth}
		\begin{align*}
			\begin{array}{rl}
				& \mathbb{F}(\neg \varphi), X \\
			      \cline{2-2}
			      & \mathbb{T}(\varphi), X
			\end{array}
		\end{align*}
		\end{minipage}
		
		\paragraph{Conjunction}
This is a binary operation which means that the output of these rules is more complex than the negation rules.
The conjunction rule for a formula signed as valid decomposes the formula in two subformulas and assert the validity of both of them.
On the other hand the conjunction rule for a formula signed as invalid splits the branch into two branches and asserts the invalidity of the subformulas in each branch respectively.
		\newline
		\noindent\begin{minipage}{.5\linewidth}
		\begin{align*}
			\begin{array}{rl}
				& \mathbb{T}(\varphi \: \wedge \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, \mathbb{T}\psi, X
			\end{array}
		\end{align*}
		\end{minipage}%
		\begin{minipage}{.5\linewidth}
		\begin{align*}
			\begin{array}{rl}
				& \:\:\: \mathbb{F}(\varphi \: \wedge \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{F}\varphi, X \:\:\:\:\:\:\:\: \mathbb{F}\psi, X
			\end{array}
		\end{align*}
		\end{minipage}

		\paragraph{Disjunction}
This is a binary operation which means that the output of these rules is more complex than the negation rules.
The disjunction rule for a formula signed as valid splits the branch into two branches and asserts the validity of the subformulas in each branch respectively.
On the other hand the disjunction rule for a formula signed as invalid decomposes the formula in two subformulas and assert the invalidity of both of them.
		\newline
		\noindent\begin{minipage}{.5\linewidth}
		\begin{align*}
			\begin{array}{rl}
				& \:\:\: \mathbb{T}(\varphi \: \vee \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, X \:\:\:\:\:\:\:\: \mathbb{T}\psi, X
			\end{array}
		\end{align*}
		\end{minipage}%
		\begin{minipage}{.5\linewidth}
		\begin{align*}
			\begin{array}{rl}
				& \mathbb{F}(\varphi \: \vee \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{F}\varphi, \mathbb{F}\psi, X
			\end{array}
		\end{align*}
		\end{minipage}
		
		\paragraph{Implication}
The implication as well is a binary operation and depending on the asserting sign it decomposes the formula in two subformulas or splits into two separate branches.
		\newline
		\noindent\begin{minipage}{.5\linewidth}
		\begin{align*}
			\begin{array}{rl}
				& \:\:\: \mathbb{T}(\varphi \: \rightarrow \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{F}\varphi, X \:\:\:\:\:\:\:\: \mathbb{T}\psi, X
			\end{array}
		\end{align*}
		\end{minipage}%
		\begin{minipage}{.5\linewidth}
		\begin{align*}
			\begin{array}{rl}
				& \mathbb{F}(\varphi \: \rightarrow \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, \mathbb{F}\psi, X
			\end{array}
		\end{align*}
		\end{minipage}
		
		\paragraph{Equivalence}
Both of the equivalence rules split the branch into separate branches, the details can be observed in the following equations.
		\newline
		\noindent\begin{minipage}{.5\linewidth}
		\begin{align*}
			\begin{array}{rl}
				& \:\:\:\:\:\:\:\: \mathbb{T}(\varphi \: \leftrightarrow \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, \mathbb{T}\psi, X \:\:\:\:\:\:\:\: \mathbb{F}\varphi, \mathbb{F}\psi, X
			\end{array}
		\end{align*}
		\end{minipage}%
		\begin{minipage}{.5\linewidth}
		\begin{align*}
			\begin{array}{rl}
				& \:\:\:\:\:\:\:\: \mathbb{F}(\varphi \: \leftrightarrow \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, \mathbb{F}\psi, X \:\:\:\:\:\:\:\: \mathbb{F}\varphi, \mathbb{T}\psi, X
			\end{array}
		\end{align*}
		\end{minipage}
		\newline
		\paragraph{Closed branch}
A branch is said to be closed if and only if it contains the same formula signed as valid and invalid.

		\paragraph{Closed tableau}
A tableau is said to be closed if after the decomposition process all branches are closed.

		\paragraph{Tautology formula} 
The process to determine if a formula is tautology is as follows:
Let $\varphi$ be a formula 
\begin{enumerate}
	\item Sign the formula as invalid, namely let $\mathbb{F}\varphi$ be the initial formula in the tableau process
	\item Execute the tableau process until the tableau contains only basic formulas in each branch
	\item If all branches are closed, then the formula is a tautology otherwise it is not.
\end{enumerate}

	The tableau method is best explained through examples. First let us see an example of a formula which is a tautology.
		\par
	Consider the following formula $((\neg X \wedge (Y \rightarrow X)) \rightarrow \neg Y$
	\newline
	\\\indent\indent\indent\indent\indent\indent 1. $\mathbb{F} (((\neg X \wedge (Y \rightarrow X)) \rightarrow \neg Y)$
	\\\indent\indent\indent\indent\indent\indent 2. $\mathbb{T} ((\neg X \wedge (Y \rightarrow X)),  \mathbb{F}\neg Y$
	\\\indent\indent\indent\indent\indent\indent 3. $\mathbb{T} ((\neg X \wedge (Y \rightarrow X)),  \mathbb{T} Y$
	\\\indent\indent\indent\indent\indent\indent 4. $\mathbb{T}\neg X , \mathbb{T} (Y \rightarrow X),  \mathbb{T} Y$
	\\\indent\indent\indent\indent\indent\indent 5. $\mathbb{F} X , \mathbb{T} (Y \rightarrow X),  \mathbb{T} Y$
	\\
	\begin{tikzpicture}[scale = 0.8]
		\draw (-6.5,0) (5,1);
        \draw[thick] (-2,0) -- (-0.4,1) -- (1.6,0);
    \end{tikzpicture}
	\\\indent\indent\indent\indent\indent\;\; 6. $\mathbb{F} Y$  \indent\indent\indent\indent\;\; 7. $\mathbb{T} X$
	\par
	
		\par
The first step of our tableau method for proving if a formula is a tautology is to sign it as not valid and analyze it. This means that at 1. this signed formula is added to the root of the tableau method. In the next step there is only one possibility, namely to decompose the only formula currently in the tableau process. This formula is decomposed to two formulas present in 2. 
At this point there are 2 possible outcomes, the first one is to decompose the formula $\mathbb{T} ((\neg X \wedge (Y \rightarrow X))$. The second one is to decompose the formula $\mathbb{F}\neg Y$. In this example we have chosen the second approach and the result is present in step 3, namely $\mathbb{F}\neg Y$ after a tableau step is $\mathbb{T} Y$. From step 3 to step 4 there is only one possibility. The $\mathbb{T}\neg X$ formula is decomposed to $\mathbb{F} X$. in step 5. Now the decomposition of the formula $\mathbb{T} (Y \rightarrow X)$ will split the tableau branch into two branches. $\mathbb{F} Y$ will be added in the one of the branches, which in turn will contradict with $\mathbb{T} Y$ which can be observed from step 3. This means that the branch closes. In the other branch $\mathbb{T} X$ is added which contradicts with $\mathbb{F} X$ from the previous step. This as well means that the second branch closes. Having a tableau with all branches closed proves that the initial assumption to sign the formula as invalid was wrong, hence the formula is a tautology.
	\newline

	The following tableau method is not closed and after the tableau process reaches all basic formulas a model in which the formula is not 
	valid can be constructed. The formula used is $X \rightarrow (Y \vee (\neg(X \vee Y) \wedge Y))$.
	\newline
	\\\indent\indent\indent\indent\indent\indent 1. $\mathbb{F} (X \rightarrow (Y \vee (\neg(X \vee Y) \wedge Y)))$
	\\\indent\indent\indent\indent\indent\indent 2. $\mathbb{T} X, \mathbb{F} (Y \vee (\neg(X \vee Y) \wedge Y)))$
	\\\indent\indent\indent\indent\indent\indent 3. $\mathbb{T} X, \mathbb{F} Y,  \mathbb{F} (\neg(X \vee Y) \wedge Y)))$
	\\
	\begin{tikzpicture}[scale = 0.8]
		\draw (-7,0) (5,1);
        \draw[thick] (-2,0) -- (-0.4,1) -- (1.6,0);
    \end{tikzpicture}
	\\\indent\indent\indent\indent\indent\; 4. $\mathbb{F}\neg (X \vee Y)$  \indent\indent\indent\;\; 5. $\mathbb{F} Y$
	\\\indent\indent\indent\indent\indent\; 6. $\mathbb{T} X \vee Y$
	\\
		\begin{tikzpicture}[scale = 0.8]
		\draw (-7,0) (5,1);
        \draw[thick] (-3.2,0) -- (-2.3,1) -- (-1.4,0);
    \end{tikzpicture}
	\\\indent\indent\indent\indent 8. $\mathbb{T} X$  \indent\indent\;\; 9. $\mathbb{T} Y$
	\par
	\par
In step 1 the input formula is signed as not valid and added to the tableau. This signed formula is decomposed into two signed formulas in step 2. Where one of them is already a basic formula and can not be decomposed in simpler signed formulas. The second one is decomposed and the results can be seein in step 3. Again one of the new signed formulas is a basic formula. The only formula that can  be decomposed is $\mathbb{F} (\neg(X \vee Y) \wedge Y)))$ which splits the tableau branch.In the splitted branch $\mathbb{F} Y$ is added, this is step 5. This formula does not cause a contradiction in the branch and since there are no more possible decompositions it follows that the branch is not closed. At this point we knoww that the tableau is not closed. However for the purposes of this example let us examine the rest of the tableau process. In step 4 we can observe the additional signed formula which was added to the main branch. This signed formula is decomposed with the usage of one of the negation rules, as seen in step 6. Applying the disjunction rule for a formula signed as true on the formula in step 6 cases a branch split. Only one of the branches closes, namely the formula added in step 8. From this follows that the tableau is not closed and that the initial assumtion was true, namely the formula is not a tautology.
	\par
	\newpage
	\section{Region-based Contact Logics}
The region-based theory of space has the notion of region and relations between regions as one of the basic primitive notions of the theory.
A region is defined as a set of elements in some space. Union and intersection are used as primary operations over regions.
Two relations are introduced, part-of relation and contact relation. 
The part-of relation constructs the structural dependencies between regions, namely the part-of relations defines the mereology of regions.
The contact relation defines the topological relation of connection. We will abstract ourselfs from the inner relation between two connected regions, namely
this relation might be defined as "region A and region B are neightbours". What we will use for this inner relation is its reflexivity and symmetry.
%talk about terms
%talk about formulas
	\subsection{Syntax}

	\paragraph{Variable} 
represents a region. Two predefined variables shall be used in order to simplify the notation. 
		\begin{itemize}
			\item W represents the whole world, namely the biggest region which contains all elements.
			\item $\emptyset$ represents the empty region
		\end{itemize}
Let $\mathbb{V}ar$ be a countable set of all variables.

	\paragraph{Boolean constants}
Boolean constants are defined for W and $\emptyset$, namely 1 represents the world, while 0 represents the empty region.

	\paragraph{Boolean operations}
are operations over regions. The followings are boolean operations:
		\begin{itemize}
			\item $\sqcap$, denotes boolean intersection
			\item $\sqcup$, denotes boolean union
			\item * , denotes boolean complement
		\end{itemize}

	\paragraph{Term} 
is defined with the following inductive definitions:
	\label{sec:term-inductive-definition}
		\begin{itemize}
			\item Boolean constant is a term
			\item $p \in \mathbb{V}ar$ is a term
			\item If x is a term, then *x is a term
			\item If x and y are terms, then $x \; \sigma \; y $ is a term,\\
				where $\sigma \: \in \: \{\sqcap, \sqcup\}$
		\end{itemize}	

	\paragraph{Propositional constants}
$\top$ and $\bot$ 

	\paragraph{Propositional connectives} 
$\neg, \vee, \wedge, \rightarrow, \leftrightarrow$

	\paragraph{Atomic Formulas}
		A formula $\varphi$ is called atomic, if it has one of the following forms:
		\begin{itemize}
			\item C(a, b), where a and b are terms
			\item a <= b, where a and b are terms
		\end{itemize}

	\paragraph{Formula}
is defined by the following inductive definition:
	\label{sec:formula-inductive-definition}
		\begin{itemize}
			\item Each propositional Constant is a formula
			\item Each atomic formula is a formula 
			\item If $\varphi$ is a formula, then $\neg{\varphi}$ is a formula as well
			\item If $\varphi$ and $\psi$ are formulas, then $\varphi \: \sigma \: \psi $ is a formula as well,\\
				where $\sigma \in \{\vee, \wedge, \rightarrow, \leftrightarrow\}$
		\end{itemize}

	\paragraph{Zero term formula}
		Let a and b be two terms, then
		\begin{equation}
			a \le b \iff a \sqcap \neg b = \emptyset
		\end{equation}

		$a \sqcap \neg b = \emptyset$ will be called zero term formula.
		Since $a \sqcap \neg b$ is a new term, it can be assigned a variable $s = a \sqcap \neg b$, 
		and now the zero term formula above can be written as $s  = 0$ which is with better readability and 
		can be straightforwardly grasped in proofs and definitions.


	\subsection{Semantics}
Our goal is to define the semantics of a formula and to answer the question when a given formula is satisfiable.
When trying to define the satisfiability of a formula, couple of questions arise, such as:
		\begin{itemize}
			\item How is a region represented 
			\item What does it mean for two regions to be in contact
			\item In which scope is the formula satisfiable
		\end{itemize}
Let us first define the semantics of a formula which will lead us to its evaluation and satisfiability.
\newline
Let W be a countable set and $W \neq \emptyset$. This set will represent all elements in the world.
A region will be a subset of W. Namely a set of elements represents a region.
Let $R \subseteq W^2$ be a binary relation over regions. The relation R defines the contacts between regions.
The relation R is a reflexive and symmetric relation. \\
For example let us take:
		\begin{equation*}
			W = \text{"the set of all countries in the world"}
		\end{equation*}
With the above W, we can define the relation R, for example let $x, y \in W$, then:
		\begin{equation*}
			R = \text{"x has similar population count with y"}
		\end{equation*}

Having (W, R) as defined above, we conclude the followings: 
		\begin{equation*}
			R(\text{ Germany, Turkey })
		 \end{equation*}
		\begin{equation*}
			R(\text{ Bulgaria } \sqcup \text{ Macedonia , Austria })
		 \end{equation*}
A relation system is defined as $\mathcal{F} = (W, R)$, where $W \neq \emptyset$. $\mathcal{F}$ is usually called a frame.

	\paragraph{Boolean variable evaluation}
Let $\mathcal{F}$  be a frame, then a boolean variable evaluation is any function $\mathscr{v}$ assignig to each Boolean variable a subset $v(a) \subseteq W$. The evaluation is then extended inductively to all Boolean terms as follows
		\begin{itemize}
			\item $v(0) = \emptyset$
			\item $v(1) = W$
			\item $v(a \sqcap b) = v(a) \cap v(b)$
			\item $v(a \sqcup b) = v(a) \cup v(b)$
			\item $v(a*) = W \ v(a)$
		\end{itemize}

The pair $\mathcal{M} = (\mathcal{F}, \mathscr{v})$ is called a model. The truth of a formula $\varphi$ in $\mathcal{M}$ ( in symbols $\mathcal{M} \models \varphi$) is defined inductively as follows:
		\begin{itemize}
			\item $\mathcal{M} \not\models \bot$ 
			\item $\mathcal{M} \models \top$
			\item $\mathcal{M} \models a \leq b \text{ iff } v(a) \subseteq v(b)$
			\item $\mathcal{M} \models aCb \text{ iff } v(a) \text{ iff } (\exists x \in v(a)), (\exists y \in v(b)) (xRy)$
			\item $\mathcal{M} \models \neg \varphi \text{ iff } \mathcal{M} \not\models \varphi$
			\item $\mathcal{M} \models a \; \sigma \; b \text{ iff } \mathcal{M} \models a \: \sigma \: \mathcal{M} \models b$, where $\sigma \in \{ \vee, \wedge \}$
		\end{itemize}
In the previously defined semantics we evaluate formulas not locally at points, as it is in the standard modal semantics, but globally in the whole model and this is one of the main differences of the present modal approach with the standard Kripke approach.

A model $\mathcal{M}$ is a model of a formula $\varphi$  if $\varphi$ is true in $\mathcal{M}$; $\mathcal{M}$ is a model of a set of formulas A if $\mathcal{M}$ is 
a model of all formulas from A. A formula $\varphi$ is true in a frame $\mathcal{F}$, or that $\mathcal{F}$ is a frame for $\varphi$, in symbols $\mathcal{F} \models \varphi$,
if $\mathcal{M} \models \varphi$ for all models $\mathcal{M}$ based on $\mathcal{F}$, i.e. for all evaluations $\mathscr{v}$ we have $\mathcal{F}, \mathscr{v} \models \varphi$.
If $\Sigma$ is a class of frames, we say that $\varphi$ is true in $\Sigma$, in symbols $\Sigma \models \varphi$, if $\varphi$ is true in all frames in $\Sigma$. We say that a set of 
formulas A is satisfiable in $\Sigma$, or A is $\Sigma$-consistent, if there is a model $\mathcal{M} = (\mathcal{F}, \mathscr{v})$ with $\mathcal{F} \in \Sigma$ such that $\mathcal{M}$
is a model of A.
	\newpage
	\section{Quantative Contact Logics}

	\newpage
	\section{Implementation Introduction}

	\newpage
	\section{Tableaux Implementation}

	\newpage
	\section{Model Implementation}

	\newpage
	\section{Quantative Contact Logics Implementation}
	
	






























\end{document}