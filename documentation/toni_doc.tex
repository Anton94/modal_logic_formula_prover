 \documentclass{article}

\usepackage{algorithm2e}
\usepackage[noend]{algpseudocode}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{systeme}
\usepackage{newtxtext}
\usepackage{newtxmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage{makecell}
\usepackage{booktabs}% http://ctan.org/pkg/booktabs
\usepackage{float}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{multirow}

\usetikzlibrary{trees}

\SetKw{KwBy}{by}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}
\algnewcommand{\algorithmicgoto}{\textbf{go to}}%
\algnewcommand{\Goto}[1]{\algorithmicgoto~\ref{#1}}

\usetikzlibrary{arrows.meta}

\restylefloat{table}
\newcommand{\tabitem}{~~\llap{\textbullet}~~}

\newcommand\eqdef{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\scriptsize\sffamily def}}}{=\joinrel=}}}

\newcommand\M{\mathcal{M}}
\newcommand\F{\mathcal{F}}
\newcommand\p{\mathcal{P}}
\newcommand\V{\mathcal{V}}
\newcommand\E{\mathcal{E}}
\newcommand\VXi{X_i}
\newcommand\VX{X}
\newcommand\Tn{\mathcal{T}_n}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{defn}[theorem]{Deffinition}
\newcommand{\BranchConjunction}{%
\begin{alignat}{2}
			\bigwedge_{i=1}^{I} \; C(a_i, b_i) \:\: \wedge \:\: &
			\bigwedge_{j=1}^{J} \; d_j \neq 0 \:\: \wedge \:\:
			\bigwedge_{k=1}^{K} \; \neg C(e_k, f_k) \:\: \wedge \:\: &
			\bigwedge_{l=1}^{L} \; g_l = 0 \:\:
\end{alignat}%
}


\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\title{Satisfiability Of Connected Contact Logics}
\date{2019-9-28}
\author{Anton Dudov}

\begin{document}
	\maketitle
	\newpage

	\tableofcontents

	\newpage

	\section{Tableau Method For Classic Propositional Logic}

	\subsection{What Is A Tableau?}
	A tableau method is a formal proof procedure. First, it could be used as a refutation procedure: to show a formula X is valid we begin with some syntactical expression intended to assert it is not. This expression is broken down syntactically, generally splitting things into several cases. This part of a tableau procedure - the tableau expansion stage - can be thought of as a generalization of disjunctive normal form expansion. Generally, it moves from formulas to subformulas. Finally, there are rules for closing cases: impossibility conditions based on syntax. If each case closes, the tableau itself is said to be closed. A closed tableau beginning with an expression asserting that X is not valid is a tableau proof of X. \par	
	There is a second way of thinking about the tableau method: as a search procedure for models meeting certain conditions. Each branch of a tableau can be considered to be a partial description of a model. In automated theorem-proving, tableaus can be used to generate counter-examples. \par	
	The connection between the two roles for tableaus - as a proof procedure and as a model search procedure - is simple. If we use tableaus to search for a model in which X is false, and we produce a closed tableau, no such model exists, so X must be valid.

	\subsection{Classical Propositional Tableaus}
	We will look into the signed tableau system for classical propositional logic.

	\par
	First, we need syntactical machinery for asserting the invalidity of a formula, and for doing case analysis. For this purpose two signs are introduced: $T$ and $F$, where these are simply two new symbols, not part of the language of formulas. \textit{Signed formulas} are expressions of the form $F X$ and $T X$, where X is a formula. The intuitive meaning of $F X$ is that X is \textit{false} (in some model). Similarly, $T X$ intuitively asserts that X is \textit{true}. Then $F X$ is the syntactical device for (informally) asserting the invalidity of X. A tableau proof of X begins with $F X$.

	\par
	Next, we need machinery (rules) for breaking signed formulas down and doing a case division. We will define rules for each logical operator ($\neg \land \lor \Rightarrow \Leftrightarrow$).

	\par
	The treatment of \textbf{negation} is straightforward: from \textit{T $\neg$X} we get \textit{F X} and from \textit{F $\neg$X} we get \textit{T X}. These rules can be conveniently presented as follows.

	\[
		\frac{T \neg X}{F X}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\ \frac{F \neg X}{T X}
	\]

	\par

	The rules for \textbf{conjunction} are somewhat more complex. From truth tables we know that if $X \land Y$ is \textit{true}, X must be \textit{true} and Y must be \textit{true}. Likewise, if $X \land Y$ is \textit{false}, eigher X is \textit{false} or Y is \textit{false}. This involves a split into two cases. Corresponding syntactic rules are as follows.
	\[
		\frac{T X \land Y}{\displaystyle{T X \atop T Y}}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\ \frac{F X \land Y}{F X \mid F Y}
	\]

	The rules for \textbf{disjunction} are similar. From truth tables we know that if $X \lor Y$ is \textit{true}, eigher X is \textit{true} or Y is \textit{true}. This involves a split into two cases. Likewise, if $X \lor Y$ is \textit{false}, X must be \textit{false} and Y must be \textit{false}. Corresponding syntactic rules are as follows.
	\[
		\frac{T X \lor Y}{T X \mid T Y}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\ \frac{F X \lor Y}{\displaystyle{F X \atop F Y}}
	\]

	\par
	The rules for \textbf{implication}. From truth tables we know that if $X \Rightarrow Y$ is \textit{true}, eigher X is \textit{false} or Y is \textit{true}. Likewise, if $X \Rightarrow Y$ is \textit{false}, X must be \textit{true} and Y must be \textit{false}. Corresponding syntactic rules are as follows.
	\[
		\frac{T X \Rightarrow Y}{F X \mid T Y}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\ \frac{F X \Rightarrow Y}{\displaystyle{T X \atop F Y}}
	\]

	\par
	The rules for \textbf{equivalence}. From truth tables we know that if $X \Leftrightarrow Y$ is \textit{true}, eigher X is \textit{true} and Y is \textit{true} or X is \textit{false} and Y is \textit{false}. Likewise, if $X \Rightarrow Y$ is \textit{false}, eigher X is \textit{true} and Y is \textit{false} or X is \textit{false} and Y is \textit{true}. Corresponding syntactic rules are as follows.
	\[
		\frac{T X \Leftrightarrow Y}{\left.\displaystyle{T X \atop T Y}\right\vert\displaystyle{F X \atop F Y}}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\ \frac{F X \Leftrightarrow Y}{\left.\displaystyle{T X \atop F Y}\right\vert\displaystyle{F X \atop T Y}}
	\]

	\par
	The standard way of displaying tableaus is as downward branching trees with signed formulas as node labels. Indeed, the tableau method is often referred to as the tree method. Think of a tree as representing the disjunction of its branches, and a branch as representing the conjunction of the signed formulas on it.

	\par
	When using a tree display, a tableau expansion is thought of temporally, and one talks about the stages of constructing a tableau, meaning the stages of growing a tree. The rules given above are thought of as branch-lengthening rules. Thus, a branch containing \textit{T $\neg$ X} can be lengthened by adding a new node to its end, with \textit{F X} as a label. Likewise a branch containing \textit{F X $\lor$ Y} can be lengthened with two new nodes, labelled \textit{F X} and \textit{F Y} (take the node with \textit{F Y} as the child of the one labelled \textit{F X}). A branch containing \textit{T X $\lor$ Y} can be split - its leaf is given a new left and a new right child, with one labelled \textit{T X}, the other \textit{T Y}. This is how the schematic rules above are applied to trees.
	\par
	An important point to note is that the tableau rules are non-deterministic. They say what can be done, not what must be done. At each stage, we choose a signed formula occurrence on a branch and apply a rule to it. Since the order of choice is arbitrary, there can be many tableaus for a single signed formula.
	\par
	Here is the final stage of a tableau expansion beginning with the signed formula $F (X \land Y) \Rightarrow (\neg X \land \neg Y)$.
	\\\indent\indent\indent\indent 1. $F(X \land Y) \Rightarrow \neg(\neg X \lor \neg Y)$
	\\\indent\indent\indent\indent 2. $TX \land Y$
	\\\indent\indent\indent\indent 3. $F\neg(\neg X \lor \neg Y)$
	\\\indent\indent\indent\indent 4. $T X$
	\\\indent\indent\indent\indent 5. $T Y$
	\\\indent\indent\indent\indent 6. $T\neg X \lor \neg Y$
	\\
	\begin{tikzpicture}[scale = 0.8]
		\draw (-4,0) (4,1);
        \draw[thick] (-1.5,0) -- (0,1) -- (1.5,0);
    \end{tikzpicture}
	\\\indent\indent\;\;  7. $T \neg X$  \indent \indent\indent 8. $T \neg Y$
	\\\indent\indent\;\; 9. $F X$ \indent\indent\indent 10. $F Y$

	\par
	In this we have added numbers for reference purposes. Items 2 and 3 are from 1 by $F \Rightarrow $. 4 and 5 are from 2 by $T \land$. 6 is from 3 by $F \neg$. 7 and 8 are from 6 by $T \lor$. 9 is from 7 by $T \neg$. 10 is from 8 by $T \neg$.
	\par
	Finaly, the conditions for closing off a case (declaring a branch closed) are	simple. A \textbf{branch is closed} if it contains a contradiction, i.e. $T A$ and $F A$ for some formula $A$. A \textbf{branch is opened} if it does not contain any contradiction. If each branch is closed, then the \textbf{tableau is closed}. A closed tableau for $F X$ is a tableau proof of $X$, meaning that A is a tautology. The tableau displayed above is closed, so the formula $(X \land Y) \Rightarrow (\neg X \land \neg Y)$ has a tableau proof.
	\par
	It may happen that no tableau proof is forthcoming, and we can think of the tableau construction as providing us with contraexamples. Consider the following attempt to prove $(X \Rightarrow Y) \Rightarrow ((Y \Rightarrow X) \Rightarrow \neg Y)$
	\\\indent\indent\indent\indent\indent\indent 1. $F ((X \Rightarrow Y) \Rightarrow ((Y \Rightarrow X) \Rightarrow \neg Y))$
	\\\indent\indent\indent\indent\indent\indent 2. $T X \Rightarrow Y$
	\\\indent\indent\indent\indent\indent\indent 3. $F ((Y \Rightarrow X) \Rightarrow \neg Y)$
	\\\indent\indent\indent\indent\indent\indent 4. $T Y \Rightarrow X$
	\\\indent\indent\indent\indent\indent\indent 5. $F \neg Y$
	\\\indent\indent\indent\indent\indent\indent 6. $T Y$
	\\
	\begin{tikzpicture}[scale = 0.8]
		\draw (-5,0) (5,1);
        \draw[thick] (-2,0) -- (-0.4,1) -- (1.6,0);
    \end{tikzpicture}
	\\\indent\indent\indent 7. $F X$  \indent\indent\indent\indent\;\; 8. $T Y$
	\\
	\begin{tikzpicture}[scale = 0.8]
		\draw (-5,0) (5,1);
        \draw[thick] (-3.2,0) -- (-2.3,1) -- (-1.4,0);
        \draw[thick] (1,0) -- (2,1) -- (3,0);
    \end{tikzpicture}
	\\\indent\;\; 9. $F Y$ \indent 10. $T X$  \indent 11. $F Y$ \indent 12. $T X$
	\par
	Item 2 and 3 are from 1 by $F \Rightarrow$, as are 4 and 5 from 3. Item 6 is from 5 by $F \neg$. Items 7 and 8 are from 2 by $T \Rightarrow$, as are 9 and 10 from 4. Items 11 and 12 are also from 4 by $T \Rightarrow$. The leftmost branch is closed because of 6 and 9. The left-right branch is closed because of 7 and 10. The right-left branch is closed because of 8 and 11. But the rightmost branch is not closed. Notice that every non-atomic signed formula has had a rule applied to it on this branch and there is nothing left to do. (For clasical propositional logic it is sufficient to apply a rule to a formula on a branch only once.) In fact the branch yields a counterexample, as follows. Let $\upsilon$ be a propositional valuation that maps X to \textit{true} and Y to \textit{true} in accordance to 8 and 12. Now, we work our way back up the branch. Since $\upsilon(Y) = true$, $\upsilon(\neg Y) = false$, item 5. From $\upsilon(X) = true$ follows that $\upsilon(Y \Rightarrow X) = true$, item 4. From $\upsilon(Y) = true$ follows that $\upsilon(X \Rightarrow Y) = true$, item 2. Since $\upsilon(Y \Rightarrow X) = true$ and $\upsilon(\neg Y) = false$ we have $\upsilon((Y \Rightarrow X) \Rightarrow \neg Y) = false$, item 3. Finally, $\upsilon((X \Rightarrow Y) \Rightarrow ((Y \Rightarrow X) \Rightarrow \neg Y)) = false$, item 1.
	\par
	Later, we are going to use the tableau method to produce a model in which the initial formula is valid.
	\par
	From a different point of view, we can think of a classical tableau simply as a set of sets of signed formulas: a tableau is the set of its all branches, and a branch is the set of signed formulas that occur on it. Semantically, we think of the outer set as the disjunction of its members, and these members, the inner sets, as conjunctions of signed formulas they contain. Considered this way, a tableau is a generalization of disjunctive normal form (a generalization because of formulas more complex than literals can occur). Now, the tableau construction process can be thought of as a variation of the process of converting a formula into a disjunctive normal form. 	

	\newpage
	\section{Contact Logics}
	\subsection{Syntax}
	The language of contact logic consist of:
	\begin{itemize}
		\item \textit{Boolean variables} (a denumerable set $\V$)
		\item \textit{Boolean constants}: 0 and 1
		\item \textit{Boolean operations}:
		\begin{itemize}
			\item $\sqcap$ boolean meat
			\item $\sqcup$ boolean join
			\item $^*$ boolean complement
		\end{itemize}
		\item \textit{Boolean terms} (or simply \textit{terms})
		\item \textit{Propositional connectivies}: $\neg$, $\land$, $\lor$, $\Rightarrow$, $\Leftrightarrow$
		\item \textit{Propositional constants}: $\top$ and $\bot$
		\item \textit{Modal connectives}: $\leq$(part-of) and $C$(contact)
		\item \textit{Complex formulas} (or simply \textit{formulas})
	\end{itemize}

	\noindent\textbf{\textit{Terms}} are defined in the following inductive process:
	\begin{itemize}
		\item Each Boolean variable is a term
		\item Each Boolean constant is a term
		\item If $a$ is a term then $a^*$ is a term
		\item If $a$ and $b$ are terms then $a \sqcap b$ and $a \sqcup b$ are terms
	\end{itemize}

	\noindent\textbf{\textit{Atomic formulas}} are of the form $a \leq b$ and $aCb$, where $a$ and $b$ are terms.

	\noindent\textbf{\textit{Formulas}} are defined in the following inductive process:
	\begin{itemize}
		\item Each propositional constant is a formula
		\item Each atomic formula is a formula
		\item If $\phi$ is a formula then $\neg\phi$ is a formula
		\item If $\phi$ and $\psi$ are formulas then ($\phi \land \psi$), ($\phi \lor \psi$), ($\phi \Rightarrow \psi$) and ($\phi \Leftrightarrow \psi$) are formulas
	\end{itemize}

	\noindent\textbf{\textit{Abbreviations}}:
		$a = b \eqdef (a \leq b) \land (b \leq a)$,
		$a \nleq b \eqdef \neg(a \leq b)$,
		$a \neq b \eqdef \neg(a = b)$

	\subsection{Relational semantics}
	\label{relational-system}

	\par
	Let $\F$ = (W, R) be a relational system with W $\neq$ $\emptyset$ and R $\subseteq$ $W^2$. We call such systems \textit{frames}. Following Galton[TODO] we may give a spatial meaning of frames naming the elements of W, \textit{cells} and the relation R, \textit{adjacency relation}. Then $\F$ is called \textit{adjacency space}. An example of adjacency space is the chess-board table, the cells are the squares, and two squares are adjacent if they have a common point.

	\par
	Originally Galton assumed R to be a reflexive and symmetric relation but it is more natural for R to be an arbitrary relation. \textit{Regions} in an adjacency space are arbitrary subsets of W and two sets $a$ and $b$ are in \textit{contact} ($aC_Rb$) if for some $x \in a$ and $y \in b$ we have $xRy$. Another way to define this relation is the following. For a subset $a \subseteq W$ define as in modal logic $\langle R \rangle a = \{ x \in W : (\exists y \in W)(xRy$ and $y \in a)\}$. Then $aC_Rb$ iff $a \cap \langle R \rangle b \neq \emptyset$ iff $\langle R^{-1} \rangle a \cap b \neq \emptyset$, where $R^{-1}$ is the converse relation of R. Note that if R is a symmetric relation then $aCb$ iff $a \cap \langle R \rangle b \neq \emptyset$ iff $\langle R \rangle a \cap b \neq \emptyset$.

	\begin{defn}
		\label{valuation}
		By a \textbf{\textit{valuation}} of the Boolean variables in $\F$ we mean any function $\upsilon : \V \rightarrow \p(W)$ assigning to each Boolean variable $b$ a subset $\upsilon(b) \subseteq W$. The valuation $\upsilon$ is then extended inductively to all Boolean terms as follows:

		\begin{itemize}
			\item $\upsilon(0) = \emptyset$
			\item $\upsilon(1) = W$
			\item $\upsilon(a \sqcap b) = \upsilon(a) \cap \upsilon(b)$
			\item $\upsilon(a \sqcup b) = \upsilon(a) \cup \upsilon(b)$
			\item $\upsilon(a^*) = W \setminus \upsilon(a) = -\upsilon(a)$
		\end{itemize}
	\end{defn}

	\begin{defn}
		The pair $\M$ = ($\F, \upsilon$) is called \textbf{\textit{model}}. The truth of a formula $\phi$ in $\M$ ($\M \models \phi$ or $\F, \upsilon \models \phi$) is extended inductively to all Boolean terms as follows:
		\begin{itemize}
			\item For atomic formulas:
				\begin{itemize}
					\item $\M \models \top$
					\item $\M \not\models \bot$
					\item $\M \models a \leq b \iff \upsilon(a) \subseteq \upsilon(b)$
					\item $\M \models aCb \iff \upsilon(a)$ $C_R$ $\upsilon(b$ $\iff (\exists x \in \upsilon(a))(\exists y \in \upsilon(b))(xRy)$
				\end{itemize}
			\item For complex formulas:
				\begin{itemize}
					\item $\M \models \neg \phi \iff \M \not\models \phi$
					\item $\M \models \phi \land \psi \iff \M \models \phi$ and $\M \models \psi$
					\item $\M \models \phi \lor \psi \iff \M \models \phi$ or $\M \models \psi$
					\item $\M \models \phi \Rightarrow \psi \iff \M \not\models \phi$ or $\M \models \psi$
					\item $\M \models \phi \Leftrightarrow \psi \iff$ ($\M \models \phi$ and $\M \models \psi$) or ($\M \not\models \phi$ and $\M \not\models \psi$)
				\end{itemize}
		\end{itemize}
	\end{defn}
	\par
	Let us note that in the above semantics we evaluate formulas not locally at points[ TODO ??], as it is in the standard modal semantics, but globally in the whole model and this is one of the main differences of the present modal approach with the standard Kripke approach.

	\begin{defn}
		A model $\M$ is a \textit{\textbf{model of a formula}} $\phi$ if $\phi$ is \textit{true} in $\M$.
	\end{defn}

	\begin{defn}
		If $\phi$ has a model $\M$, then $\phi$ is \textbf{satisfiable}.
	\end{defn}

	\begin{defn}
		$\M$ is a \textbf{model of a set of formulas} $A$ if $\M$ is a model of all formulas from A.
	\end{defn}

	\begin{defn} A formula $\phi$ \textbf{is \textit{true}} (or \textbf{valid}) in a frame $\F$ ($\F \models \phi$), if $\M \models \phi$ for all models $\M$ based on $\F$, i.e. for all valuations $\upsilon$ we have $\F$,$\upsilon \models \phi$.
	\end{defn}

	\begin{lemma}
		(Equality of formulas) Let f and g are formulas. Then \par $f = g \implies \upsilon(f) = \upsilon(g)$.
	\end{lemma}

	\begin{lemma}
		(Equality of terms) Let a and b are terms. Then \par $a = b \implies \upsilon(a) = \upsilon(b)$.
	\end{lemma}

	\begin{lemma} (Zero term) Let a and b are terms. Then \par $a \leq b \implies a \sqcap b^*=0$
	\end{lemma}

	\begin{lemma} (Non-zero term) Let a and b are terms. Then \par $\neg(a \leq b) \implies a \sqcap b^* \neq 0$
	\end{lemma}

	TODO: axiom or lemma or neither??
	\begin{axiom}
		(Reflexivity) Let a be a term. Then \par $ a \neq 0 \implies aCa$.
	\end{axiom}

	\begin{axiom}
		(Symmetry) Let a and b are terms. Then \par $aCb \iff bCa$.
	\end{axiom}

	\begin{lemma}
		(Monotonicity) Let a and b are terms. Then \par $aCb \land a \leq a' \land b \leq b' \implies a'Cb'$.
	\end{lemma}

	\begin{lemma}
		(Distributivity) Let a and b are terms. Then \par $aC(b \sqcup c) \iff aCb \lor aCc$, \; TODO what is the other one? $aC(b \sqcup c) \iff aCb \lor aCc$.
	\end{lemma}

	\begin{lemma}
		Let a, b, c are terms and f, g are formulas. The following formulas are true:
		\begin{itemize}
			\item $f \land T \implies f$, $T \land f \implies f$
			\item $f \land F \implies F$, $F \land f \implies F$
			\item $f \lor T \implies T$, $T \lor f \implies T$
			\item $f \lor F \implies f$, $F \lor f \implies f$
			\item $a \sqcap 0 \implies 0$, $0 \sqcap a \implies 0$
			\item $a \sqcup 0 \implies a$, $0 \sqcup a \implies a$
			\item $a \sqcap 1 \implies a$, $1 \sqcap a \implies a$
			\item $a \sqcup 1 \implies 1$, $1 \sqcup a \implies 1$
			\item $(a \sqcup b)Cc \iff aCc \lor bCc$
			\item $(a \sqcup b) \leq c \iff a \leq c \land b \leq c$
			\item $aCb \implies a \neq 0 \land b \neq 0$
			\item $a \sqcap b \neq 0 \implies aCb$
			\item $a = 0 \lor b = 0 \implies \neg(aCb)$
			\item $0 \leq a \implies T$
			\item $a \leq 1 \implies T$
			\item $0C0 \implies F$
			\item $aC0 \implies F$
			\item $1C1 \implies T$
			\item $aC1 \implies a \neq 0$
			\item $a \neq 0 \implies aCa$
		\end{itemize}
	\end{lemma}

	\subsection{Formula satsfiability}
		Let $\psi$ be a propositional formula. Let us build a tableau beginning with $\psi$. If the tableau has an opened branch then $\psi$ is satisfiable. Unfortunately, for the contact logic this is not enough because we need to verify the modal connectives ($\leq$ and $C$).
		\paragraph{}
		Let $\phi$ be a formula. Let us build a tableau beginning with $\phi$. Let the tableau has an opened branch $B$. The branch $B$ is a set of signed atomic formulas of the following type:
		\begin{itemize}
			\item $T C(a,b)$
			\item $F C(e,f)$
			\item $T a \leq b$
			\item $F a \leq b$
		\end{itemize}
		where a and b are terms.

		\noindent $B$ is an opened branch, so there are no contradicting formulas in it, i.e. $(\neg \exists X)(T X \in B \land F X \in B)$.
		The signed atomic formulas could be written as atomic formulas as follows:
		\begin{itemize}
			\item $T C(a,b)$ $\rightarrow$ $C(a,b)$ (contact)
			\item $F C(a,b)$ $\rightarrow$ $\neg C(a,b)$ (non-contact)
			\item $T a \leq b$ $\rightarrow$ $a \leq b$ $\rightarrow$ $a \sqcap b^*=0$ $\rightarrow$ $g = 0$ (zero term)
			\item $F a \leq b$ $\rightarrow$ $\neg (a \leq b)$ $\rightarrow$ $a \sqcap b^* \neq 0$ $\rightarrow$ $d \neq 0$ (non-zero term)
		\end{itemize}
			\noindent where a,b,d and g are terms.

		All atomic formulas in the branch should be satisfied, so we can think of it as a conjunction of them. Let's call it a \textbf{branch conjunction}. It is sufficient to build a satisfiable model for the branch conjuction to verify that $\phi$ is satisfiable. Building  such a model could be done a lot more effective than building a model for an arbitrary formula because it is just a conjuction.
		\begin{defn}
			\label{branch-conjunction}
			Let $\phi$ be a formula. Let T be a tableau beginning with $\phi$. Let B be a set of all atomic signed formulas in a branch of T, as follows:
			\begin{alignat}{2}
				B = \{T C(a_i, b_i) \mid i \in \{1, \ldots, I\} \} \cup
					\{F d_j = 0 \mid j \in \{1, \ldots, J\} \} \cup \\\nonumber
					\{F C(e_k, f_k) \mid k \in \{1, \ldots, K\} \} \cup
					\{T g_l = 0 \mid l \in \{1, \ldots, L\} \}
			\end{alignat}
		\end{defn}
		A \textbf{branch cojnuction} $\beta$ is the following formula:
		 \BranchConjunction

	\subsection{Branch conjunction model building}
		The branch conjunction formula $\beta$ is satisfiable if $\beta$ has a model $\M$. We have to construct such a model $\M$ = ($\F, \upsilon$) = ((W, R), $\upsilon$). 
		\begin{defn}
			A denumerable set of $n$ boolean variables $\V_n$ is defined as follows:
			\begin{equation}
				\label{boolean-evaluation}
				\V_n = \{x_1, x_2, \ldots , x_n \}
			\end{equation}
		\end{defn}
		Let n be the number of the unique boolean variables in $\beta$. Let $\V_n$ be the set of them. There are four types of atomic formulas in $\beta$, namely contacts, non-contacts, zero terms and non-zero terms. Only contacts and non-zero terms require existance of modal points. The valuation $\upsilon$ should assign a set of modal points to each boolean variable $x \in \V_n$. One way to define $\upsilon$ and W is the following:
		
		\begin{itemize}
			\item Assign an empty set of modal points for each boolean variable $x \in \V_n$.
	
			$\upsilon$ = \{ <x, $\emptyset$> $\mid$ $ x \in \V_n$ \}
			
			\item Add a modal point for each term in the contacts and non-zero terms of $\beta$. 
			
			W = \{ $p_i$ $\mid$ C($a_i$, $b_i$) $\in$ $\beta$ \} $\cup$ \{ $p_{I+i}$ $\mid$ C($a_i$, $b_i$) $\in$ $\beta$ \} $\cup$ \{ $p_{I*2+j}$ $\mid$ $d_j \neq 0$ $\in$ $\beta$ \}
						
			\item Extend $\upsilon$ such as:
			
			\begin{itemize}
				\item $p_i$ $\in$ $\upsilon(a_i)$ for each C($a_i$, $b_i$) $\in$ $\beta$ 
				\item $p_{I+i}$ $\in$ $\upsilon(b_i)$ for each C($a_i$, $b_i$) $\in$ $\beta$ 
				\item $p_{I*2+j}$ $\in$ $\upsilon(d_j)$ for each $d_j$  $\neq$ 0 $\in$ $\beta$ 
			\end{itemize}
		\end{itemize}
				
		\begin{defn}
			Let $\V_n$ be a denumerable set of $n$ boolean variables. Let W be a set of modal points. Let $\upsilon$ be a valuation over $\V_n$ and W. Then $\VXi$ $\subseteq$ W is the evaluation set of the boolean variable $x_i$ in $\V_n$.
			\begin{equation}
				\VXi = \upsilon(x_i) \;for x_i \in \V_n
			\end{equation}
		\end{defn}
		
		\begin{defn}
			Let $\V_n$ be a denumerable set of $n$ boolean variables. Let W be a set of modal points. Let $\upsilon$ be a valuation over $\V_n$ and W.
			Then $\VX$ is the union of all evaluations of boolean variables in $\V_n$.
			\begin{equation}
				\VX = \bigcup\limits_{x_i \in \V_n}\upsilon(x_i) = \bigcup\limits_{x_i \in \V_n}\VXi
			\end{equation}
		\end{defn}
		
		Let t be an arbitrary term. Let p $\notin$ W be a new modal point. Let us extend $\upsilon$ such as p $\in$ $\upsilon(t)$. By the valuation definition  $\upsilon(t)$ is a composition of interesections, unions and compliments of some $\VXi$ $\subseteq$ W. Therefore, the modal point p should be added to zero or more $\VXi$ depending on the boolean operations in the term t. With n boolean variables there are $2^n$ ways of adding the point p.
		
		
		
		\begin{defn}
			A \textbf{variable evaluation $\E_n$} for $n$ boolean variables is a sequence of 1s and 0s, as follows:
			\begin{equation}
				\E_n = \; < e_1, e_2, \ldots , e_n >, \; where \; e_1, \ldots, e_n \in \{0, 1 \}
			\end{equation}
		\end{defn}

		For $n$ boolean variables there are $2^n$ unique variable evaluations. We will define the modal points as variable evaluations. By the definition of the valuation, it is not possible to distinguish two or more different modal points in some subsets. For example, the W $\setminus$ $\VX$ subset. The modal point representation also have this limitaion. The modal connectives require existence of a point in those sets. It is sufficient to work with only one point from them.

		\begin{defn}
			Let $\E_n$ be a variable evaluation for $n$ boolean variables. Then $(\E_n)^i$ is the i-th element in the sequence $\E_n$.
		\end{defn}

		\begin{defn}
			Let $\V_n$ be a denumerable set of $n$ boolean variables. The set of \textbf{all unique variable evaluations $W_n$} over $n$ variables is defined as follows:
			\begin{equation}
				\label{all-unique-points}
				W_n = \{< e_1, e_2, \ldots , e_n > \mid e_1, \ldots, e_n \in \{0, 1 \} \}
			\end{equation}
		\end{defn}

		\begin{defn}
			\label{valuation-modal-points}
			Let $\V_n$ be a denumerable set of $n$ boolean variables. Let $W_n$ be the set of all unique points over n variables. Let W $\subseteq$ $W_n$. Then the \textbf{valuation $\upsilon_n : \V_n \rightarrow \p(W)$} is inductively defined as follows:
			\begin{itemize}
				\item Boolean constants
					\begin{itemize}
						\item $\upsilon_n(0) = \emptyset$
						\item $\upsilon_n(1) = W$
					\end{itemize}
				\item Boolean variables
					\begin{itemize}
						\item $\upsilon_n(x_i) = \{ \E_n \mid \E_n \in W \land (\E_n)^i = 1 \}$, for $x_i \in \V_n$
					\end{itemize}
				\item Boolean terms
					\begin{itemize}
						\item $\upsilon_n(a \sqcap b) = \upsilon_n(a) \cap \upsilon_n(b)$
						\item $\upsilon_n(a \sqcup b) = \upsilon_n(a) \cup \upsilon_n(b)$
						\item $\upsilon_n(a^*) = W \setminus \upsilon_n(a) = -\upsilon_n(a)$
					\end{itemize}
			\end{itemize}
		\end{defn}

		Let $\beta$ be a branch conjunction as in \ref{branch-conjunction} . Let W be a set of modal points. Let $\V_n$ be the set of boolean variables in $\beta$. Let $\upsilon_n$ be a valuation as in \ref{valuation-modal-points} . Let $W \subseteq W_n$. Let R $\subseteq$ $W^2$ be a reflexive and symetric relation.

		\begin{defn}
			The zero terms in $\beta$ are satisfied iff each zero term's valuation is the empty set.
			\begin{equation}
				(\forall (g_l = 0) \in \beta)(\upsilon_n(g_l) = \emptyset)
			\end{equation}
		\end{defn}

		\begin{defn}
			The non-contacts in $\beta$ are satisfied iff:
			\begin{equation}
				(\forall_{\neg C(e_k, f_k) \in \beta})\neg(\exists x \in \upsilon_n(e_k))(\exists y \in \upsilon_n(f_k))(xRy)
			\end{equation}
		\end{defn}

		\begin{lemma}
			The valuations of the non-contact terms in $\beta$ does not have a common modal point. Follows from the reflexivity of R.
			\begin{equation}
				(\forall_{\neg C(e_k, f_k) \in \beta})(\upsilon_n(e_k) \cap \upsilon_n(f_k) = \emptyset)
			\end{equation}
		\end{lemma}

		\begin{defn}
			Let t be an arbitrary boolean term. Then $\V_t$ is the set of the boolean variables used in t.
		\end{defn}

		\begin{defn}
			Let $\V_n$ be a denumerable set of boolean variables. Then $\Tn$ is the set of all boolean terms with variables of $\V_n$.
			\begin{equation}
				\Tn = \{t \mid t \;is\; a \;boolean \;term \;and \;\V_t \subseteq \V_n \}
			\end{equation}
		\end{defn}

		\begin{defn}
			Let $\V_n$ be a denumerable set of boolean variables. Let $\Tn$ be the set of all boolean terms with variables of $\V_n$. Let W $\subseteq$ $W_n$. By a \textbf{boolean valuation} of a boolean term in $\Tn$ we mean the function $\eta$. It assigns a boolean constant for each pair of term t $\in$ $\Tn$ and variable evaluation $\E_n \in W_n$.
			\begin{equation}
				\eta(t, \E_n) \in \{0, 1\}
			\end{equation}
			Let t $\in$ $\Tn$. Let $\E_n \in W_n$. The inductive definition of $\eta$ on the structure of the term t is as follows:
			\begin{itemize}
				\item $\eta(0, E_n) = 0$
				\item $\eta(1, E_n) = 1$
				\item $\eta(x_i, E_n) = (E_n)^i$		
				\item $\eta(a \sqcap b, E_n) = \eta(a, E_n) \sqcap \eta(b, E_n)$
				\item $\eta(a \sqcup b, E_n) = \eta(a, E_n) \sqcup \eta(b, E_n)$
				\item $\eta(a^*, E_n) = \;^*\eta(a, E_n)$
			\end{itemize}
		\end{defn}

		\begin{lemma}
			Let t $\in \Tn$ be an arbitrary term. Let W $\subseteq$ $W_n$. Let $\E_n$ $\in$ W. Let $\eta$ be a boolean valuation. Let $\upsilon_n$ be a valuation as in \ref{valuation-modal-points} . By the definition of $\eta$ and $\upsilon_n$ follows:
			\begin{equation}
				\eta(t, \E_n) = 1 \iff \E_n \in \upsilon_n(t)
			\end{equation}
		\end{lemma}

		\begin{defn}
			Let t $\in \Tn$ be an arbitrary term. Let $\eta$ be a boolean valuation. Let $\E_n$ $\in$ $W_n$. Then $\mathbf{\E_n \; satisfies \; t}$ iff $\E_n$ evaluates t to the constant 1.
			\begin{equation}
				\E_n \; satisfies \; t \iff \eta(t, \E_n) = 1
			\end{equation}
		\end{defn}

		\begin{defn}
			Let t $\in \Tn$ be an arbitrary term. Let $\eta$ be a boolean valuation. The set of all variable evaluations $\E_t$ which satisfies t is defined as follow:
			\begin{equation}
				\E_t = \{ \E_n \mid \E_n \in W_n \land \eta(t, \E_n) = 1 \}
			\end{equation}
		\end{defn}

		\begin{defn}
			Let $\E_n \in W_n$. Let W $\subseteq W_n$. Let W = $W \cup {\E_n}$. Then $\E_n$ is a $\mathbf{valid \; modal \; point \; of \; \beta}$ if it does not break the satisfaction of the zero terms and non-contacts in $\beta$:
			\begin{align*}
				(\forall (g_l = 0) \in \beta)(\E_n \notin \upsilon_n(g_l)) \land
				(\forall_{\neg C(e_k, f_k) \in \beta})(\E_n \notin \upsilon_n(e_k) \cap \upsilon_n(f_k)) \iff \\
				(\forall (g_l = 0) \in \beta)(\eta(g_l, \E_n) = 0) \land
				(\forall_{\neg C(e_k, f_k) \in \beta})(\eta(e_k, \E_n) = 0 \land \eta(f_k, \E_n) = 0)
			\end{align*}
		\end{defn}

		\begin{defn}\label{set-all-valid-modal-points}
			Let $W^v \subseteq W_n$ be the set of all valid modal points of $\beta$.
			\begin{equation}
				W^v = \{ \E_n \mid \E_n \in W_n \land \E_n \; is \; a \; valid \; modal \; point \; of \; \beta \}
			\end{equation}
		\end{defn}

		\begin{defn}
			Let x, y $\in W^v$. Then <x, y> is a $\mathbf{valid \; connected \; pair \; of \; \beta}$ modal points if it does not break the satisfaction of non-contacts in $\beta$.
			\begin{align*}
			(\forall_{\neg C(e_k, f_k) \in \beta})\neg(
			(x \in \upsilon_n(e_k) \land y \in \upsilon_n(f_k)) \:\lor \\
			(x \in \upsilon_n(f_k) \land y \in \upsilon_n(e_k)) \:\lor \\
			(x \in \upsilon_n(e_k) \land y \in \upsilon_n(e_k)) \:\lor \\
			(x \in \upsilon_n(f_k) \land y \in \upsilon_n(f_k))) \\ \:\iff \\
			(\forall_{\neg C(e_k, f_k) \in \beta})\neg(
			(\eta(e_k, x) = 1 \land \eta(f_k, y) = 1) \:\lor \\
			(\eta(f_k, x) = 1 \land \eta(e_k, y) = 1) \:\lor \\
			(\eta(e_k, x) = 1 \land \eta(e_k, y) = 1) \:\lor \\
			(\eta(f_k, x) = 1 \land \eta(f_k, y) = 1))
			\end{align*}
		\end{defn}

		\begin{defn}\label{set-all-valid-modal-point-pairs}
			Let $R^v \subseteq {W^v}^2$ be the set of all valid connected pairs of $\beta$ modal points.
			\begin{equation}
				R^v = \{ <x, y\> \mid x, y \in W^v \land <x, y> \; is \; a \; valid \; connected \; pair \; of \; \beta \; modal \; points\}
			\end{equation}
		\end{defn}

		\begin{lemma}\label{satisfied-contacts-non-zero-terms}
			Let $\F = (W^v, R^v)$ be a relational system. $\F$ satisfies the contacts and non-zero terms in $\beta$ iff:
			\begin{align*}
				(\forall (d_j \neq 0) \in \beta)(\exists \E_n \in W^v)(\E_n \in \upsilon_n(d_j)) \: \land \\
				(\forall_{C(a_i, b_i) \in \beta})(\exists <x, y> \in R^v)(x \in \upsilon_n(a_i) \land y \in \upsilon_n(b_i)) \\ \iff \\
				(\forall (d_j \neq 0) \in \beta)(\exists \E_n \in W^v)(\eta(d_j, \E_n) = 1 \: \land \\
				(\forall_{C(a_i, b_i) \in \beta})(\exists <x, y> \in R^v)(\eta(a_i, x) = 1 \land \eta(b_i, y) = 1)
			\end{align*}
		\end{lemma}

			Let $\F = (W^v, R^v)$. Let $\M = (\F, \upsilon_n)$. $\M$ satisfies the zero terms and non-contacts in $\beta$. $\M$ is a model of $\beta$ if the non-zero terms and contacts are satisfied \ref{satisfied-contacts-non-zero-terms} .

			The model $\M$ is not convenient. It might have a lot of modal points and connections between them. For example, let $\beta = C((x \sqcap y) \sqcap z, t \sqcup e)$. Then $\V_n = \{x, y, z, t, e\}$. There are no zero terms and non-contacts, so $W^v$ is the same as $W_n$. Therefore, $|W^v|= 32$ and $|R^v| = 32^2$.

	The following algorithm builds a more convenient model. Creates modal points and connections only for the non-zero and contact terms in $\beta$.

		\LinesNumbered
		\DontPrintSemicolon
		\begin{algorithm}
			$W \gets \emptyset$
			\;
			$R \gets \emptyset$
			\;
			\tcc{Process the non-zero terms in $\beta$}
			\For{$d_j \neq 0 \in \beta$}{\label{non-zero-terms}
				\For{$\E_n \in W^v$}{
					\uIf{$\eta(d_j, \E_n) = 1$}{
						$W \gets W \cup \{ x \}$
						\;
						$R \gets R \cup \{ <x,x> \}$
						\;
						\Goto{non-zero-terms}
					}
				}
				Unable to construct a model.
			}
			\tcc{Process the contacts in $\beta$}
			\For{$C(a_i, b_i) \in \beta$}{\label{contacts}
				\For{$<x, y> \in R^v$}{
					\uIf{$\eta(a_i, x) = 1 \land \eta(b_i, x) = 1$}{
						$W \gets W \cup \{x, y \}$
						\;
						$R \gets R \cup \{<x,x>, <y,y>, <x,y>, <y,x> \}$
						\;
						\Goto{contacts}
					}
				}
				Unable to construct a model.
			}
			Successfully constructed a model $\M = ((W, R), \upsilon_n)$.
		\end{algorithm}

	\newpage
	\section{Connected Contact Logics}

	\subsection{Connectivity}
	In topology and related branches of mathematics, a connected space is a topological space that cannot be represented as the union of two or more disjoint non-empty open subsets. Connectedness is one of the principal topological properties that are used to distinguish topological spaces.

	\begin{axiom}
		(Connectivity) Let b is a term. Then
		\label{connectivity-theorem}\begin{equation}
			b \neq 0 \land b \neq 1 \implies bCb^*
		\end{equation}
	\end{axiom}

	\paragraph{} Let $\F$ = (W, R) be a relational system with W $\neq$ $\emptyset$, R $\subseteq$ $W^2$ and a, b are terms. Let us recall the deficition of C:
	\begin{equation}
		aCb \iff (\exists x \in \upsilon(a)) (\exists y \in \upsilon(b))(xRy)
	\end{equation}

	\paragraph{} The connectivity theorem can be written as follows:
	\begin{equation}
		\upsilon(b) \neq \emptyset \land \upsilon(b) \neq W \implies (\exists x \in \upsilon(b)) (\exists y \in W \setminus \upsilon(b))(xRy)
	\end{equation}

	\begin{defn}
		Let G = (W, R) be a graph. W is the set of vertexes and R the set of edges. A \textbf{path} $\pi(v_1, v_n)$ is a sequence of vertexes $(v_1, v_2, \dotsc , v_n)$ such that $v_1,\dotsc,v_n \in V$ and $v_iRv_{i+1}$, for $i \in \{1,\dotsc,n-1\}$.
	\end{defn}

	\begin{defn}
		Let $G = (W, R)$ be an undirected graph. $W$ is the set of vertexes and R the set of edges. $G$ is $\mathbf{connected}$ if there is a path between each two vertices in $W$.
		\begin{equation}
			(\forall x \in W)(\forall y \in W)(\exists \pi(x, y)) (\pi(x, y)\;is\;a\;path\;in\;G)
		\end{equation}
	\end{defn}

	Let $G = (W, R)$. The connectivity theorem implies that there is a connection out of each evaluation set(except the $\emptyset$ and W). Mind that the modal point representation is a variable evaluation. Thus, the set of all evaluations is  $\p(W)$.

	If G is connected, then there is a path between each two points. Therefore, there is a connection out of each $W' \in \p(W)$.
		\begin{equation}
			(\forall W' \in \p(W))(W' \neq \emptyset \land W' \neq W \implies(\exists x \in W')(\exists y \in W \setminus W)(xRy))
		\end{equation}

	If G is disconnected, then G has a not connected components. Let G'=(W', R') be such a component. Thus, $W' \subseteq W$ and $W' \in \p(W)$. There are no outgoing connections from W'. Otherwise, G' would be connected with at least one more point from $W \setminus W'$.
		\begin{equation}
			(\exists W' \in \p(W))(W' \neq \emptyset \land W' \neq W \land (\not\exists y \in W \setminus W')(xRy))
		\end{equation}

	Therefore, the connectivity theorem implies that the graph G is connected.

	\begin{defn}
		Let $\F$ = (W, R) be a relational system. Let $\M = (\F, \upsilon_n)$ be a model of $\beta$. $\M$ is a \textbf{connected model} if $G = (W, R)$ is connected.
	\end{defn}

	\subsection{Connected model building}

		Let $\beta$ be a branch conjunction as in \ref{branch-conjunction} :
		\nonumber\BranchConjunction

		Let $\F^v = (W^v, R^v)$ be a relational system. Let $\M^v = (\F^v, \upsilon_n)$ be a model. $\M^v$ is a model of $\beta$ if the non-zero terms and contacts in $\beta$ are satisfied \ref{satisfied-contacts-non-zero-terms} .	If $\M^v$ is not a model of $\beta$, then $\beta$ does not have a model neither a connected model.

		Let $\M^v$ is a model of $\beta$. $\M^v$ is the biggest model of $\beta$ w.r.t unique modal points and connections between them. Let $G^v=(W^v, R^v)$ be the graph of $\F^v$.

		\begin{defn}
			Let G'=(W', R') and G''=(W'', R'') are an undirected graphs. G' and G' $\mathbf{does \; not \; overlap}$ iff:
			\begin{equation}
				W' \cap W'' = \emptyset \land R' \cap R'' = \emptyset
			\end{equation}
		\end{defn}

		\begin{defn}
			Let $F = (W, R)$ be a relational system. Let $G = (W, R)$ be an undirected graph. Then $Comp^G$ is the splitting of G to it's $\mathbf{connected \; components}$ .
			\begin{align*}
				Comp^G = \{G'=(W', R') \mid W' \subseteq W \land R' \subseteq R \land G'\;is\;connected \} \land \\
				(\forall \; G' \in Comp^G)(\forall \; G'' \in Comp^G)(G' \; and \; G'' \; does \; not \; overlap) \land \\
				\{ W' \mid G'=(W', R') \in Comp^G \} = W \land \{ R' \mid G'=(W', R') \in Comp^G \} = R
			\end{align*}
		\end{defn}

		Let $Comp^{G^v}$ is the set of the connected components of $G^v$. If $Comp^{G^v}$ contains a graph which defines a model of $\beta$, then it is a connected model, too. Otherwise, $\beta$ does not have a connected model.

		Let $G' \in Comp^{G^v}$. Let $\M' = (W', R', \upsilon_n)$ is a model. In order $\M'$ to be a model of $\beta$ the non-zero terms and contacts in $\beta$ should be satisfied \ref{satisfied-contacts-non-zero-terms} . The zero terms and non-contacts are satisfied because $\M'$ has not introduces new modal points neither a connections.

	\newpage
	\section{Implementation Introduction}
	The main programming language is C++. Flex \& Bison are used to parse the input formula. The formula proover is a C++ library. The unit and performance tests are C++ applications.
	The user application is a Web page. The Web server is implemented with the third party CppRestSDK library. The satisfiability checking runs on the server. There is a feature to interupt an ongoing process. Can be triggered by the user via a button. There is a user disconnecting detection which cancels the requested formula prooving.
	TODO: something more? maybe some screenshots from the web application or in it's section is enough?
		
	\subsection{Syntax}
	The formula should be easy and intuitive to write. Only the keyboard keys should be used. The legend bellow describes the formula's syntaxis:

	\begin{center}
	\begin{tabular}{ |c|c|c| }
		\hline
		\multicolumn{3}{|c|}{\textbf{Terms}} \\
		\hline
		0 				    & 0      & Boolean constant 0 \\
		1 					& 1      & Boolean constant 1 \\
		- 					& *      & Boolean complement \\
		*				 	& $\cap$ & Boolean meat \\
		+ 					& $\cup$ & Boolean join \\
		()                  & ()     & Parentheses \\
		\text{[a-zA-Z0-9]+} & $x_1$  & Boolean variable. Syntax $x1$, $Y42$, $Var101$ \\
		\hline
		\hline
		\multicolumn{3}{|c|}{\textbf{Formulas}} \\
		\hline
		F      & $\bot$            & Propositional constant false \\
		T      & $\top$            & Propositional constant true \\
		$\sim$ & $\neg$            & Negation \\
		$\&$   & $\land$           & Conjunction \\
		$|$    & $\lor$            & Disjunction \\
		->     & $\Rightarrow$     & Implication \\
		<->    & $\Leftrightarrow$ & Equivalence \\
		C      & C                 & Contact, syntax C($t_1$, $t_2$) \\
		<=     & $\leq$            & Part of , syntax <=($t_1$, $t_2$) \\
		<=m    & $\leq$$m$$$       & Measured Part of, syntax <=m($t_1$, $t_2$) \\
		=0     & =0                & Zero term, syntax $t_1=0$ \\
		()     & ()                & Parentheses \\
		\hline
	\end{tabular}
	\end{center}

	These are a few examples of formulas:
	\begin{itemize}
		\item $C(x1 * 1, x2 + y1)$
		\item $C(x1 + 0, (-x2 + x3) * x1)$
		\item $C(x1,x2) \;\&\; C(x2, x3) \;\& \sim C(x1,x3)$
		\item $C(x1,x2) \;\& <=(x1,x3) \;\& \sim C(x2,x3)$
		\item $C(x1,x2) \text{ -> } C(x2, x1)$
		\item $C(x1,x2) \;\&\; C(x2, x3) => C(x1, x3)$
		\item $F \text{ -> } C(x1,x2) \;\& \sim C(x1,x2)$
	\end{itemize}

	\subsection{Formula parsing}
	The formula is a sequence of characters. These characters does not give us any information for the formula's structure. It should be analyzed. Flex \cite{flex-tokenizer} and Bison \cite{bison-parser} are used to parse it into an AST (Abstract Syntax Tree). Flex is used as a tokenizer. Bison is used as the parser.

	\subsubsection{Abstract Syntax Tree}
	The AST is a binary tree. Each node has an operation type and up to two children. The formula nodes are prior term nodes. A formula node could have term node as children. Term nodes could not have a formula node as a child. The leaves are variables or constants.
	
	Let $\phi = (C(x1,x2) \;\& <=(x2, x3)) => C(x1, x3)$. The following is an AST of $\phi$:

\begin{tikzpicture}[
  tlabel/.style={pos=0.6,right=-1pt,font=\footnotesize\color{red!70!black}},
]
\label{AST-phi}
\node{=>}
child {node {$\&$}
  child {node {C}
    child {node {x1}}
    child {node {x2}}
  }
  child[missing] {}
  child {node {<=}
    child {node {x2}}
    child {node {x3}}
  }
}
child[missing] {}
child[missing] {}
child {node {C}
  child {node {x1}}
  child {node {x3}}
};
\end{tikzpicture}

	\newpage
	\paragraph{Operation types} Enum structure is used to represent the type of formulas and terms in a memory efficient way.

	\begin{lstlisting}[language=C++]
enum class formula_operation_t
{
    constant_true,
    constant_false,
    conjunction,
    disjunction,
    negation,
    implication,
    equality,
    contact,
    less_eq,
    measured_less_eq,
    eq_zero
};

enum class term_operation_t
{
    constant_true,
    constant_false,
    union_, // union is a keyword
    intersection,
    complement,
    variable
};
	\end{lstlisting}

	\newpage
	\paragraph{Node types} There are two types of nodes. Formula nodes and term nodes. They are defined with a separate classes.

	\begin{lstlisting}
class Node
{
    ...
};

class NFormula : public Node
{
public:
    NFormula(formula_operation_t op,
             Node* left = nullptr, Node* right = nullptr);
    ...

    formula_operation_t op;
    Node* left;
    Node* right;
};

class NTerm : public Node
{
public:
    NTerm(term_operation_t op,
          NTerm* left = nullptr, NTerm* right = nullptr);
    ...

    term_operation_t op;
    NTerm* left;
    NTerm* right;
    std::string variable;
};
	\end{lstlisting}

	\subsubsection{Tokenizer}
	The tokenizer is responsible for demarcating the special sybmols in the input formula.
	After the symbols are identified a token is created for each of them or at least for those significant to the semantic of the input formula.
	For example, the whitespaces are not significant and a tokens are not created for them.
	We shall use Flex as a tokenizer \cite{flex-tokenizer}.

	\paragraph{Grammar} The tokenizer's grammar is composed from two types of tokens. Single character and multi character.

	The Single character tokens are directly matched in the input formula and are representing the token itself.
	The multi character token is a sequence of characters which have some meaning when bundled together.
	This tokenizer's grammar is unambiguous and each input formula is uniquely tokenized.

	The tokens derivation is explaned in details in the following table with Flex syntax. The matched symbol represents the symbol from the input formula and the output token is the newly created token for the matched symbol.

		\begin{flushleft}
			\centering
			\begin{tabular}{ | m{10em} | m{15em}| } 
				\hline
					\textbf{Matched sequence} & \textbf{Output token} \\ [0.7ex] 
				\hline
					[ \textbackslash t\textbackslash  n] & ; \\
				\hline
					[,TF01()C\&|~*+-] 	& yytext[0];  \\
				\hline
				    "<="            &   T\_LESS\_EQ; \\
				\hline
				    "<=m"           &   T\_MEASURED\_LESS\_EQ; \\
				\hline
				    "= 0"           &   T\_EQ\_ZERO; \\
				\hline
				    "->"            &   T\_FORMULA\_OP\_IMPLICATION; \\
				\hline
				    "<->"           &   T\_FORMULA\_OP\_EQUALITY; \\
				\hline
				    [a-zA-Z0-9]+    &   T\_STRING; \\
				\hline
				    .               &   yytext[0]; \\
				\hline
			\end{tabular}
		\end{flushleft}
	Let us review the table above. All white spaces, tabulations and newlines are ignored. The syntax for it is the \textbf{;} character.

	All single character tokens are passed as their ASCII code. The syntax for it is \textbf{yytext[0]}. It gives the matched character. That way it will be easy to use them in the parser.

	The multi character tokens are converted to unique identificators. For example, the "<=" sequence is converted to T\_LESS\_EQ. The sequence of letters and numbers is converted to T\_STRING. Later, it will be used as a term variable.

	The last matched symbol in the table represents everything else, if nothing has been matched then just return the text itself.
	The parser will use it to promt where the unrecongized symbol was found and the symbol itself can be printed out.

% Returns T\_STRING literal type and the string  value is written to yylval which can be later accessed from the parser. Note that it uses our simple memory manager to allocate this string in order to be able to safely free all allocated strings even when some syntax error occures 

	\subsubsection{Parser}
			The single character tokens are passed as their ASCII symbol to Bison. 
			As discussed above the multi character tokens need more clearance in order to represent the literal from the input text symbols.
			The followings are definition of literals for multi character tokens:
			\begin{itemize}
				\item \%token <const char*> T\_STRING is the literal for "string"
				\item \%token T\_LESS\_EQ is the literal for "<="
				\item \%token T\_MEASURED\_LESS\_EQ is the literal for "<=m"
				\item \%token T\_EQ\_ZERO is the literal for "=0"
				\item \%token T\_FORMULA\_OP\_IMPLICATION is the literal for "->"
				\item \%token T\_FORMULA\_OP\_EQUALITY is the literal for "<->"
			\end{itemize}
			The followings are definitions of priority and associativity of the operation tokens. 
			The priority is from low to hight (w.r.t. the line order in which they are defined)
			\begin{itemize}
				\item \%left T\_FORMULA\_OP\_IMPLICATION T\_FORMULA\_OP\_EQUALITY
				\item \%left '|' '+'
				\item \%left '\&' '*'
				\item \%right '\textasciitilde' '-'
				\item \%nonassoc '(' ')'
			\end{itemize}

		\paragraph{Grammar}
			With the usage of the Parser literals, the input formula can be parsed to an Abstract Syntax Tree(AST).
			The AST contains all the data from the input string formula in a more structed way.
			On the AST additional optimizations can be done which will simplify the initial formula. It will produce better performance when a model is seeked in the satisfiability algorithms.

			For convenience, will define two helper methods. Namely, \textbf{create\_term\_node} and \textbf{create\_formula\_node}. Both method construct AST nodes.

			The create\_term\_node method creates an AST term node. It's arguments are an operation and up to two child terms. Depending on the operation arity.

			The create\_formula\_node is analogious to the create\_term\_node method. Creates an AST formula node.

			Few special symbols to define beforehand:
			\begin{itemize}
				\item \textbf{\$\$} is the return value to the 'parent'. Later, he can use it, e.g. as a child.
				\item \textbf{\$i} is the return value of the i-th matched element in the matcher sequence.
			\end{itemize}

		\paragraph{Algorithm} The following is the parser algorithm which produces an Abstract Sytax Tree.

	\begin{lstlisting}
formula // 'formula' non-terminal
    : 'T' { // matching token 'T'
        $$ = create_formula_node(constant_true);   
    }
    | 'F' {
        $$ = create_formula_node(constant_false);
    }
    | 'C' '(' term ',' term ')' {
        $$ = create_formula_node(contact, $3, $5); 
    }
    | "<=" '(' term ',' term ')' {
        $$ = create_formula_node(less_eq, $3, $5);
    }
    | "<=m" '(' term ',' term ')' {
        $$ = create_formula_node(measured_less_eq, $3, $5);
    }
    | term "=0" {
        $$ = create_formula_node(eq_zero, $1);
    }
    | '(' formula '&' formula ')' {
        $$ = create_formula_node(conjunction, $2, $4);
    }
    | formula '&' formula {
        $$ = create_formula_node(conjunction, $1, $3);
    }
    | '(' formula '|' formula ')' {
        $$ = create_formula_node(disjunction, $2, $4);
    }
    | formula '|' formula {
        $$ = create_formula_node(disjunction, $1, $3);
    }
    | '~' formula {
        $$ = create_formula_node(negation, $2);
    }
    | '(' formula "->" formula ')' {
        $$ = create_formula_node(implication, $2, $4);
    }
    | formula "->" formula {
        $$ = create_formula_node(implication, $1, $3);
    }
    | '(' formula "<->" formula ')' {
        $$ = create_formula_node(equality, $2, $4);
    }
    | formula "<->" formula {
        $$ = create_formula_node(equality, $1, $3);
    }
    | '(' formula ')' {
        $$ = $2;
    }
  ;
term
    : '1' {
        $$ = create_term_node(constant_true);
    }
    | '0' {
        $$ = create_term_node(constant_false);
    }
    | "string" {
        $$ = create_term_node(term_operation_t::variable);
        $$->variable = std::move(*$1);
        // the string is allocated from the
        // tokenizer and we need to free it
        free_lexer_string($1); 
    }
    | '(' term '*' term ')' {
        $$ = create_term_node(intersection, $2, $4);
    }
    | term '*' term {
        $$ = create_term_node(intersection, $1, $3);
    }
    | '(' term '+' term ')' {
        $$ = create_term_node(union_, $2, $4);
    }
    | term '+' term {
        $$ = create_term_node(union_, $1, $3);
    }
    | '-' term {
        $$ = create_term_node(complement, $2);
    }
    | '(' term ')' {
        $$ = $2;
    }
  ;
	\end{lstlisting}

	\subsection{Formula refinement}
	The AST can be easily modified and optimized. One of the modifications is removing the implications and equivalences. They are replaced by conjunction, disjunction and negation. This is convenient because it simplifies the tableau method. It does not have to handle implication and equivalence operations. The following is a modified AST of $\phi$ \ref{AST-phi} without the implication:
	
\begin{tikzpicture}[
  tlabel/.style={pos=0.6,right=-1pt,font=\footnotesize\color{red!70!black}},
]
\node{$|$}
child {node {$\sim$}
  child {node {$\&$}
    child {node {C}
      child {node {x1}}
      child {node {x2}}
    }
    child[missing] {}
    child {node {<=}
      child {node {x2}}
      child {node {x3}}
    }
  }
}
child[missing] {}
child[missing] {}
child {node {C}
  child {node {x1}}
  child {node {x3}}
};
\end{tikzpicture}

	\subsubsection{Visitor Pattern} The AST modification is best achieved with the visitor pattern \cite{visitor-pattern}. Uses double virtual dispatching. Separates the algorithm from the object structure on which it operates. Allows new visitors to be added in a simple manner. Each AST modification will be implemented as a visitor. Will not explain the pattern in depth. In essence, the visitor pattern requires the AST nodes to impelement a virtual \textbf{accept} method. This method accepts a visitor as argument and calls the visitor's virtual \textbf{visit} method with the real node's type. This is the double virtual dispatching. One virtual call to find the node's real type. Another to find the visitor's real type. Now, adding a new visitor requires only adding it's class. Does not require changes in the AST node classes or other visitor classes.

\newpage
\begin{lstlisting}
...
class Visitor
{
public:
    virtual void visit(NFormula& f) = 0;
    virtual void visit(NTerm& t) = 0;
};

// Example visitor(aglorithm) which will print the AST tree.
class VPrinter : public Visitor
{
public:
    void visit(NFormula& f) override
    {
        // Print the formula node's data.
    }
    void visit(NTerm& t) override
    {
        // Print the term node's data.
    }
};

class Node
{
public:
    virtual void accept(Visitor& v) = 0;
};

class NFormula : public Node
{
public:
    void accept(Visitor& v) override { v.visit(*this); }

    ...
};

class NTerm : public Node
{
public:
    void accept(Visitor& v) override { v.visit(*this); }

    ...
};
\end{lstlisting}

	\newpage
	It's worth showing the implemention of the VPrinter visit methods. They are simple and a good illustration of the pattern. Shows how the AST tree is traversed by calling the VPrinter instance with the AST's root node.
\begin{lstlisting}
void VPrinter::visit(NFormula& f)
{
    switch(f.op)
    {
        case formula_operation_t::constant_true:
            out_ << "T"; // out_ is an output stream, e.g. std::cout.
            break;
        case formula_operation_t::constant_false:
            out_ << "F";
            break;
        case formula_operation_t::conjunction:
            out_ << "(";
            f.left->accept(*this);
            out_ << " & ";
            f.right->accept(*this);
            out_ << ")";
            break;
        case formula_operation_t::disjunction:
            // Analogous to conjunction. The symbol is '|'.
        case formula_operation_t::implication:
            // Analogous to conjunction. The symbol is '->'.
        case formula_operation_t::equality:
            // Analogous to conjunction. The symbol is '<->'.
        case formula_operation_t::negation:
            out_ << "~";
            f.left->accept(*this);
            break;
        case formula_operation_t::less_eq:
            out_ << "<=(";
            f.left->accept(*this);
            out_ << ", ";
            f.right->accept(*this);
            out_ << ")";
            break;
        case formula_operation_t::measured_less_eq:
            out_ << "<=m(";
            f.left->accept(*this);
            out_ << ", ";
            f.right->accept(*this);
            out_ << ")";
            break;
        case formula_operation_t::eq_zero:
            out_ << "(";
            f.left->accept(*this);
            out_ << ")=0";
            break;
        case formula_operation_t::contact:
            out_ << "C(";
            f.left->accept(*this);
            out_ << ", ";
            f.right->accept(*this);
            out_ << ")";
            break;
        default:
            assert(false && "Unrecognized.");
    }
}

void VPrinter::visit(NTerm& t)
{
    switch(t.op)
    {
        case term_operation_t::constant_true:
            out_ << "1";
            break;
        case term_operation_t::constant_false:
            out_ << "0";
            break;
        case term_operation_t::variable:
            out_ << t.variable;
            break;
        case term_operation_t::union_:
            out_ << "(";
            t.left->accept(*this);
            out_ << " + ";
            t.right->accept(*this);
            out_ << ")";
            break;
        case term_operation_t::intersection:
            // Analogous to union_. The symbol is '*'.
        case term_operation_t::complement:
            out_ << "-";
            t.left->accept(*this);
            break;
        default:
            assert(false && "Unrecognized.");
    }
}
\end{lstlisting}

	\subsubsection{Visitors Overview}
	The following are the supported visitors. Their implementation is close to a thousand lines of code and can be checked in the repository.
	\paragraph{VReduceConstants}
	Removes all unnecessary children of And/Or/Negation operations of the following type:
			\begin{table}[H]
				  \centering
				  \begin{tabular}{llll}
				    \toprule
				    \midrule
				\tabitem \textasciitilde T $\equiv$ F & \tabitem C(0,0)  $\equiv$ F & \tabitem \textasciitilde F $\equiv$ T & \tabitem C(1,1) $\equiv$ T \\
				\tabitem (T \& T) $\equiv$ T & \tabitem C(a,0)  $\equiv$ F & \tabitem (F | F) $\equiv$ F & \tabitem C(0,a) $\equiv$ F \\
				\tabitem (g \& T) $\equiv$ g & \tabitem -1 $\equiv$ 0 & \tabitem (g | T) $\equiv$ T & \tabitem -0 $\equiv$ 1 \\
				\tabitem (T \& g) $\equiv$ g & \tabitem (1 * 1) $\equiv$ 1 & \tabitem (T | g) $\equiv$ T & \tabitem (0 + 0) $\equiv$ 0 \\
				\tabitem (g \& F) $\equiv$ F & \tabitem (t * 1) $\equiv$ t & \tabitem (g | F) $\equiv$ g & \tabitem (t + 1) $\equiv$ 1 \\
				\tabitem (F \& g) $\equiv$ F & \tabitem (1 * t) $\equiv$ t & \tabitem (F | g) $\equiv$ g & \tabitem (1 + t) $\equiv$ 1 \\
				\tabitem 0=0 $\equiv$ T & \tabitem (t * 0) $\equiv$ 0 & \tabitem 1=0 $\equiv$ F & \tabitem (t + 0) $\equiv$ t \\
				\tabitem <=(0,a) $\equiv$ T & \tabitem (0 * t) $\equiv$ 0 & \tabitem <=(a,1) $\equiv$ T & \tabitem (0 + t) $\equiv$ t \\

					    \bottomrule
				  \end{tabular}
				\end{table}

	\paragraph{VConvertContactsWithConstantTerms}
				Converts C with constant 1 terms in !=0 atomic formulas.
				This visitor is best used after the contacts are reduced, via VReduceConstants
				\begin{itemize}
					\item C(a,1) $\equiv$ \textasciitilde(a=0)
					\item C(1,a) $\equiv$ \textasciitilde(a=0)
				\end{itemize}

	\paragraph{VConvertLessEqContactWithEqualTerms}
				Converts C and <= atomic formulas with identical terms:
				\begin{itemize}
					\item <=(a,a) $\equiv$ T, \\
						since (a * -a = 0))
					\item C(a,a) $\equiv$ \textasciitilde(a=0)
				\end{itemize}

	\paragraph{VReduceDoubleNegation}
				Removes the double/tripple/etc negations.
				This visitor is best used after all visitors which might add additional negations!
				\begin{itemize}
					\item -(-g) $\equiv$ g
					\item -(-t) $\equiv$ t
				\end{itemize}

	\paragraph{VConvertImplicationEqualityToConjDisj}
				Converts all formula nodes of type implication and equality to nodes
				which are using just conjuction and disjunction. The main reason for this visitor is to simplify the formula operations.
				This visitor simplifies the formula to contain only conjunctions, disjunctions and negation operations.
				\begin{itemize}
					\item (f -> g)  $\equiv$ (\textasciitilde f | g)
					\item (f <-> g) $\equiv$ ((f \& g) | (\textasciitilde f \& \textasciitilde g))
				\end{itemize}

	\paragraph{VConvertLessEqToEqZero}
				Converts a <= formula to an equals to zero atomic formula
				\begin{itemize}
					\item <=(a,b) $\equiv$ (a * -b) = 0
				\end{itemize}

	\paragraph{VSplitDisjInLessEqAndContacts}
				Divides C and <= atomic formulas with a disjunction term into two simpler formulas
				\begin{itemize}
					\item C(a + b, c) $\equiv$ C(a, c) | C(b, c)
					\item C(a, b + c) $\equiv$ C(a, b) | C(a, c)
					\item <=(a + b, c) $\equiv$ <=(a,c) \& <=(b,c)
				\end{itemize}

	There are few visitors which only collect or print information from the formula
				\begin{itemize}
					\item VVariablesGetter - gets all variables from the formula (as string)
					\item VPrinter - prints the formula to some provided output stream
				\end{itemize}

	\subsection{Formula building}
	The formula is a binary tree. A \textbf{subformula} is a subtree in the formula's tree. The process of building a satisfiable model is computational heavy. A part of it is lexical comparing and traversing subformulas. The AST is convenient to modify the formula. These modifications are a preprocessing step. After them the formula will not be modifed. A few optimizations could be done.

	\subsubsection{Optimizations}
	\paragraph{Reducing formula operations}
	The formula operations could be reduced to not have \textit{implication}, \textit{equivalence} and \textit{less equal}. The \textit{VConvertImplicationEqualityToConjDisj} and \textit{VConvertLessEqToEqZero} visitor should be applied.

	\paragraph{Variable substitution}
	The variables are a sequence of characters, i.e. strings. It is slow to compare them. An integer ID could be assigned to each variable. One way to do it is via the \textit{VVariablesGetter} visitor. Retrieve all unique variables in a vector and use their positions as IDs.

	\paragraph{Hashing subformulas}
	Conducting a test whether two subformulas are equal in a lexical way is an important procedure for the sake of performance. Such equality checks are required in various situations. One of which is checking if a subformula exists in a set of subformulas.

	Have in mind that the naive solution to do an equality check is to compare the whole subformula strcuture. The complexity is O(n), where n is the size of the subformula. To reduce this complexity a precalcaulated hash value shall be used.
	For each formula node an additional hash variable is stored. The hash is computed recursively through the formula's structure. The hash of a parent node depends on the hashes of its children nodes. 
	The equality comparison first checks the hash codes. The full equality checking is done only for matching hash codes.

	\newpage
	\subsubsection{Layout}
	The formula structure will be similar to the AST. A couple of changes reflecting the optimizations above. The following is the final formula node's layout.

\begin{lstlisting}
class formula {
    ...
    enum class operation_type : char {
        constant_true,
        constant_false,
        conjunction,
        disjunction,
        negation,
        measured_less_eq,
        eq_zero,
        c,
        invalid,
    };

    operation_type op_;
    std::size_t hash_;

    struct child_formulas {
        formula* left;
        formula* right;
    };
    struct child_terms {
        term* left;
        term* right;
    };

    union {
        // Holds only one of the described objects.
        // Depending on the operation type the
        // child_f_ or child_t_ is "valid".
        child_formulas child_f_;
        child_terms child_t_;
    };
};

class term {
    ...
    enum class operation_type : char
    {
        constant_true,
        constant_false,
        union_,
        intersection,
        complement,
        variable,
        invalid,
    };

    operation_type op_;
    std::size_t hash_;

    struct children
    {
        term* left;
        term* right;
    };
    union {
        // Holds either children or variable id.
        // Depending on the node's operation type.
        children children_;
        size_t variable_id_;
    };
};
\end{lstlisting}

	\subsubsection{Hashing}
	The following is the implemented hash construction procedure for the term node. The formula node is analogous.
\begin{lstlisting}
void term::construct_hash()
{
  switch(op_)
  {
  case operation_t::constant_true:
  case operation_t::constant_false:
    break;
  case operation_t::union_:
  case operation_t::intersection:
    hash_ = ((children.left->get_hash() & 0xFFFFFFFF) * 2654435761) +
        children.right->get_hash() & 0xFFFFFFFF) * 2654435741);
    break;
  case operation_t::complement:
    hash_ = (children.left->get_hash() & 0xFFFFFFFF) * 2654435761;
    break;
  case operation_t::variable:
    hash_ = (variable_id_ & 0xFFFFFFFF) * 2654435761;
    break;
  default:
    assert(false && "Unrecognized.");
  }

  // Add the operation type to the hash.
  const auto op_code = static_cast<unsigned>(op_) + 1;
  hash_ += (op_code & 0xFFFFFFFF) * 2654435723;
}
\end{lstlisting}

	Let $\tau_1$ and $\tau_2$ be two terms. Let $h_1$ be the precalculated hash of $\tau_1$ and $h_2$ be the precalculated hash of $\tau_2$.
	The equality check procedure follows the following steps:
	\begin{itemize}
		\item if $h_1 \neq h_2$, then the terms are not equal
		\item if $h_1 = h_2$, then recursively compare the children.
	\end{itemize}
	\noindent

	\newpage
	\subsubsection{Conversion from AST}
	The formula building from an AST is straightforward. Recursive depth first iteration over the AST. For each AST node a coresponding formula/term node is constructed. The implementation could be found in \textit{term.cpp} and \textit{formula.cpp} in the repository.

	\newpage
	THE FOLLOWING ARE NOTES WHICH WILL BE REMOVED \\

	- Tableau - the official doc is fairly good, use it

    - In the introduction - github repo, automatic test on each commit on various of machines

	- variable evaluations - representation
		- plus one operation (Next)
		- marked bits only for the used variables
		- plus one on marked bits
	 - contact matrix representation


	 \iffalse
		Notes for the official documentation
	 - bitset-Next instead of bitet-PlusOne on marked and explain the marked before defining the
	 - variable bitset/boolean substitution does now explains anything and is confusing.
	 - Variable boolean substitution - how the substitution is done? And why we need it? What it's going to be used for?
	 - Term hash variable -> without 'variable', maybe 'member'.
	 - Term Set-Evaluation -> Maybe boolean valuation should be the correct name
	 - Variable Set-Substituitons -> maybe variable evalualuation instead of substituion. Now it's too complicated with this substituioning
	 - Term Set-Evaluation : $& |$ as cup and cap symbols maybe?
	  -
	\fi























	\newpage
	\section{Tableaux Implementation}
	The Tableaux process is a decision procedure. Recursively breaks down a given formula into basic components. Based on that a decision can be concluded. The recursive step breaks down a formula part into one or two subformulas. Continuously appling the recursive step produces a binary tree. The nodes are the formulas and the links represent the recursive step.

	All formulas in a branch are considered to be in conjunction. Contradiction may arise in a same branch if there exists a formula and its negation.

	The main principle of the tableaux is to break complex formula into smaller ones until complementary pairs of atomic formulas are produced.

	\subsubsection*{Definition: Signed formulas set}
	The signed formulas set consists only of signed formulas. The letter \textit{X} is usually used for its representation.

	\subsection{Definition: Tableaux Step}
	The \textit{Tableaux Step} takes as input a formula and a signed formulas set and produces as output one or two new formulas, depending on the operation.
	The signed formulas set consists of the broken down formulas by previous tableaux steps.
	The output of the tableaux step depends on the rule applied to the formula.

	\subsubsection{Rules}
	Only \textit{negation} \textit{conjunction} and \textit{disjunction} operations will be handled. The implication and equivalence are converted.

		\subsubsection*{Negation}
			$\begin{array}{rl}
				& \mathbb{T}(\neg \varphi), X \\
			      \cline{2-2}
			      & \mathbb{F}(\varphi), X
			\end{array}$
			\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
			$\begin{array}{rl}
				& \mathbb{F}(\neg \varphi), X \\
			      \cline{2-2}
			      & \mathbb{T}(\varphi), X
			\end{array}$

		\subsubsection*{Conjunction}
			$\begin{array}{rl}
				& \mathbb{T}(\varphi \: \wedge \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, \mathbb{T}\psi, X
			\end{array}$
			\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
			$\begin{array}{rl}
				& \:\:\: \mathbb{F}(\varphi \: \wedge \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{F}\varphi, X \:\:\:\:\:\:\:\: \mathbb{F}\psi, X
			\end{array}$

		\subsubsection*{Disjunction}
			$\begin{array}{rl}
				& \:\:\: \mathbb{T}(\varphi \: \vee \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{T}\varphi, X \:\:\:\:\:\:\:\: \mathbb{T}\psi, X
			\end{array}$
			\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:
			$\begin{array}{rl}
				& \mathbb{F}(\varphi \: \vee \: \psi), X \\
			      \cline{2-2}
			      & \mathbb{F}\varphi, \mathbb{F}\psi, X
			\end{array}$

	\newpage
	For our case the functionality of the tableaux process shall be extended. If the branch is not closed there are additional calculations needed in order to verify that there is no contradiction. Namely to verify that there is no contradiction on Term level. This means that there exists a satisfiable model.
	This verification can be done in different manners. Depending on the algorithm type. The best way to think about it is that the tableaux process returns a not-closed branch and if there is a model for the set of atomic formuas in this branch, then the formula is satisfiable, otherwise the tableaux process proceeds with the next not-closed branch. If such branch does not exist then the formula is not satisfiable. 

	\subsection{Implementation}
	The program implementation of the tableaux method follows the standard tableaux process. First interesting design decision is to keep all true signed formulas in one data set, and all false signed formulas in another data set. This enables fast searches whether a formula has been signed as true or false.

	\subsubsection*{Definition: Signed Formula Collection}
	Let X be a set of formulas, then X is called signed formula collection if and only if all formulas in X are signed as true or all formulas are signed as false.

	This collection is implemented with \textit{std::unordered\_set} (hashset), which stores the formulas by pointers to their root nodes. The hashing uses the node's precalculated hash. The comparing is via the node's \textit{operator==}. That way different pointers to subformulas with same structure will be threated as identic.

	The average complexity for search, insert and erase in this collection is O(1). There is no formula coping. So, almost no memory overhead for keeping the formulas in the set.
	\newline
	\newline
	There are 8 signed formula collections:
%Note add definition for positive and negative collections !!!
	\begin{itemize}
		\item formulas\_T - contains only non-atomic formulas signed as true
		\item formulas\_F - contains only non-atomic formulas signed as false, \\
				For example, if $\neg\varphi$ is encountered as an output of the tableaux step, then only $\varphi$ is inserted into the formula\_F
		\item contacts\_T - contains only atomic contact formulas signed as true
		\item contacts\_F - contains only atomic contact formulas signed as false
		\item zero\_terms\_T - contains only formulas of type $\varphi \le \psi$ signed as true
		\item zero\_terms\_F - contains only formulas of type $\varphi \le \psi$ signed as false
		\item measured\_less\_eq\_T - contains only formulas of type $\varphi \le_m \psi$ signed as true
		\item measured\_less\_eq\_F - contains only formulas of type $\varphi \le_m \psi$ signed as false
	\end{itemize}

	\subsubsection*{Definition: Formula Contradiction}
	Let $\varphi$ be a signed formula, then $\varphi$ is causing a contradiction if any of the following is true:
	\begin{itemize}
		\item $\varphi$ is a non-atomic signed as true and $\varphi$ belongs to $formulas\_F$
		\item $\varphi$ is a non-atomic signed as false and $\varphi$ belongs to $formulas\_T$
		\item $\varphi$ is a contact formula signed as true and $\varphi$ belongs to $contacts\_F$
		\item $\varphi$ is a contact formula signed as false and $\varphi$ belongs to $contacts\_T$
		\item $\varphi$ is a zero terms formula signed as true and $\varphi$ belongs to $zero\_terms\_F$
		\item $\varphi$ is a zero terms formula signed as false and $\varphi$ belongs to $zero\_terms\_T$
		\item $\varphi$ is a measured less formula signed as true and $\varphi$ belongs to $measured\_less\_eq\_F$
		\item $\varphi$ is a measured less formula signed as false and $\varphi$ belongs to $measured\_less\_eq\_T$
	\end{itemize}

	\subsubsection*{Invariant}
	At any time, all formulas in all eight signed formula collections do not contradict.

	A contradiction may occure if a formula is split and some of the resulting components causes a contradiction.

	\subsubsection*{Example}
	Let's assume that $contacts\_T = \{ C(a, b)\}$ and let's have a look at the following formula $\mathbb{T}(T \wedge \neg C(a,b))$.
	\newline
	By the rules of decomposition, namely the ( $\wedge$ ) rule produces $\mathbb{T}T \text{ and } \mathbb{T}\neg C(a,b)$.

	Then the $\mathbb{T}\neg C(a,b)$ will be decomposed to $\mathbb{F} C(a,b)$ by the ( $\neg$ ) rule, which causes a contradiction since $C(a,b)$ is already present in $contacts\_T$ formulas.

	\subsubsection*{Tableaux Algorithm}
	Given a formula $\varphi$, the following algorithm determines the atomic formulas in all branches of the tableaux process.

	As a first step if the formula $\varphi$ is the constant F, then false is returned directly, otherwise the whole formula $\varphi$ is inserted in $formulas\_T$.
	\newline
	\subsubsection*{Remarks}
	\begin{itemize}
		\item true boolean value is used to represent the formula constant T
		\item false boolean value is used to represent the formula constant F
		\item Contact atomic formula is commutative, meaning that: $C(a,b) \iff C(b,a)$
	\end{itemize}

	Few lemmas which will provide a much more efficient contradiction finding in the tableaux process.
	\subsubsection*{Lemma: A}
	Let x be a term. Suppose that the atomic formula $x = 0$ has already been signed as true.
	Then marking the following formulas as true will lead to contradiction:
	\begin{itemize}
		\item C(x,y)
		\item C(y,x)
	\end{itemize}
	for any term y.

	\subsubsection*{Lemma: A-inverse}
	Let x, y and z be terms. Suppose that the atomic formulas C(x,y) or C(z, x) has already been signed as true, then marking the formula x = 0 as true will lead to contradiction.
	\newline
	TODO: addd short proof.
	\subsubsection*{Time Complexity A and A-inverse}
	The algorithmic complexity to check whether a new formula leads to contradiction by Lemma A and Lemma A-inverse is done effectively. Namely in constant time with the usage of one new collection $contact\_T\_terms\_$. It keeps the terms of the true contacts. Namely the contacts in the collection $contacts\_T$. This means that for each $\mathbb{T}(C(x, y))$, the terms x and y are in the mentioned collection of true terms. The $contact\_T\_terms\_$  is a multiset and keeps track of all added terms, meaning that if the term x is added twice and then removed only once there will still be an entry of that x in the $contact\_T\_terms\_$ collection. Removing a true contact appears when moving up the tableau tree, i.e. switching to another branch.

	To check if a new formula leads to contradiction by Lemma A or Lemma A-inverse the following method is used:
\begin{lstlisting}
auto has_broken_contact_rule(const formula* f) const -> bool;
\end{lstlisting}

	\subsubsection{Handy methods}
	\subsubsection*{Searching}
	\subsubsection*{Search for formula signed as true}
\begin{lstlisting}
auto find_in_T(const formula* f) const -> bool
\end{lstlisting}
	Checks existance of formula $\varphi$ in any positive collection depending on the type of $\varphi$. Namely if $\varphi$ is of type:
	\begin{itemize}
		\item $C(x, y)$: returns whether $\varphi \in contacts\_T$
		\item $x = 0$: returns whether $\varphi \in zero\_terms\_T$
		\item $x \le_m y$: returns whether $\varphi \in measured\_less\_eq\_T$
		\item non-atomic formula: returns whether $\varphi \in formulas\_T$
	\end{itemize}

	\subsubsection*{Search for formula signed as false}
\begin{lstlisting}
auto find_in_F(const formula* f) const -> bool
\end{lstlisting}
	Checks existance of formula $\varphi$ in any negative collection depending on the type of $\varphi$. Namely if $\varphi$ is of type:
	\begin{itemize}
		\item $C(x, y)$: returns whether $\varphi \in contacts\_F$
		\item $x = 0$: returns whether $\varphi \in zero\_terms\_F$
		\item $x \le_m y$: returns whether $\varphi \in measured\_less\_eq\_F$
		\item non-atomic formula: returns whether $\varphi \in formulas\_F$
	\end{itemize}

	\subsubsection*{Adding}
	\subsubsection*{Mark formula as true}
\begin{lstlisting}
void add_formula_to_T(const formula* f)
\end{lstlisting}
	Adds the formula $\varphi$ as true in in the respective positive collection. Namely if $\varphi$ is of type:
	\begin{itemize}
		\item C(x, y): $\varphi$ is added to $contacts\_T$, and the terms x and y are added to the $contact\_T\_terms\_$
		\item $x = 0$: x is added in $zero\_terms\_T$
		\item $x \le_m y$: $\varphi$ is added to $measured\_less\_eq\_T$
		\item non-atomic formula: $\varphi$ is added to $formulas\_T$
	\end{itemize}

	\subsubsection*{Mark formula as false}
\begin{lstlisting}
void add_formula_to_F(const formula* f)
\end{lstlisting}
	Adds the formula $\varphi$ as false in the respective negative collection. Namely if $\varphi$ is of type:
	\begin{itemize}
		\item C(x, y): $\varphi$ is added to $contacts\_F$
		\item $x = 0$: x is added in $zero\_terms\_F$
		\item $x \le_m y$: $\varphi$ is added to $measured\_less\_eq\_F$
		\item non-atomic formula: $\varphi$ is added to $formulas\_F$
	\end{itemize}

	\subsubsection*{Removing}
	\subsubsection*{Remove formula signed as true}
\begin{lstlisting}
void remove_formula_from_T(const formula* f)
\end{lstlisting}
	Removes the formula $\varphi$ from the respective positive collection. Namely if $\varphi$ is of type:
	\begin{itemize}
		\item C(x, y): $\varphi$ is removed from $contacts\_T$, and the terms x and y are removed from the $contact\_T\_terms\_$.
		\item $x = 0$: x is removed from $zero\_terms\_T$
		\item $x \le_m y$: $\varphi$ is removed from $measured\_less\_eq\_T$
		\item non-atomic formula: $\varphi$ is removed from $formulas\_T$
	\end{itemize}

	\subsubsection*{Remove formula signed as false}
\begin{lstlisting}
void remove_formula_from_F(const formula* f)
\end{lstlisting}
	Removes the formula $\varphi$ from the respective negative collection. Namely if $\varphi$ is of type:
	\begin{itemize}
		\item C(x, y): $\varphi$ is removed from $contacts\_F$
		\item $x = 0$: x is removed from $zero\_terms\_F$
		\item $x \le_m y$: $\varphi$ is removed from $measured\_less\_eq\_F$
		\item non-atomic formula: $\varphi$ is removed from $formulas\_F$
	\end{itemize}

	\newpage
	\subsubsection*{Tableaux Satisfiable Step Implementation}
	The Tableaux satisfiable step is the whole Tableaux algorithm.
\begin{lstlisting}
auto tableau::satisfiable_step() -> bool
{
    // The bottom of the recursive algorithm is when we have
    // only atomic formulas(which does not contradicts).
    // Then we can run algorithms for model construction.
    if(formulas_T_.empty() && formulas_F_.empty())
    {
        // This is the method which tries
        // to construct satisfiable model.
        return has_satisfiable_model();
    }

    if(!formulas_T_.empty())
    {
        // Choosing some formula to handle in this step.
        // If this branch does not produce a valid satisfiable path,
        // then this formula will be returned to formulas_T_.
        auto f = *formulas_T_.begin();

        const auto op = f->get_operation_type();
        if(op == op_t::negation)
        {
            // T(~X) -> F(X)
            auto X = f->get_left_child_formula();
            if(X->is_constant())
            {
                // F(T) is not satisfiable
                if(X->is_constant_true())
                {
                    return false;
                }
                // F(F) is satisfiable, continue with the rest.
                return satisfiable_step();
            }

            if(find_in_T(X))
            {
                // Contradiction, we want to satisfy F(X)
                // but we already have to satisfy T(X).
                return false;
            }

            if(find_in_F(X)) // Skip adding F(X) multiple times.
            {
                return satisfiable_step();
            }

            add_formula_to_F(X);
            auto res = satisfiable_step();
            // Revert it on the way back.
            remove_formula_from_F(X);
            return res;
        }
\end{lstlisting}
\newpage
\begin{lstlisting}
        if(op == op_t::conjunction)
        {
            // T(X & Y) -> T(X) & T(Y)
            T_conjuction_child X(*this, f->get_left_child_formula());
            T_conjuction_child Y(*this, f->get_right_child_formula());

            // Checks if X breaks the contact rule
            // or brings a contradiction
            if(!X.validate())
            {
                return false;
            }
            X.add_to_T(); // Adds X to T collection

            if(!Y.validate())
            {
                X.remove_from_T();
                return false;
            }
            Y.add_to_T();

            auto res = satisfiable_step();
            X.remove_from_T();
            Y.remove_from_T();

            return res;
        }

        assert(op == op_t::disjunction);
        // T(X v Y) -> T(X) v T(Y)
        auto X = f->get_left_child_formula();
        auto Y = f->get_right_child_formula();
        trace() << "Will split to two subtrees: "
		<< *X << " and " << *Y;

        // T(T) is satisfiable and we can skip the other branch
        if(X->is_constant_true() || Y->is_constant_true())
        {
            trace() << "One of the childs is constant true";
            return satisfiable_step();
        }
\end{lstlisting}
\newpage
\begin{lstlisting}
        auto process_T_disj_child = [&](const formula* child) {
            if(child->is_constant_false() || // T(F) is not satisfiable
               find_in_F(child) || has_broken_contact_rule(child))
            {
                return false;
            }

            if(find_in_T(child)) // skip adding it multiple times
            {
                return satisfiable_step();
            }

            add_formula_to_T(child);
            const auto res = satisfiable_step();
            remove_formula_from_T(child);
            return res;
        };

        trace() << "Start of the left subtree: " << *X << " of " << *f;
        if(process_T_disj_child(X))
        {
            // There was no contradiction in the left path,
            // so there is no need to continue with the right path.
            return true;
        }

        trace() << "Start of the right subtree: " << *Y << " of " << *f;
        return process_T_disj_child(Y);
    }

    // Almost analogous but taking a formula from Fs

    // Choosing some formula to handle in this step.
    // If this branch does not produce a valid satisfiable path,
    // then this formula will be returned to formulas_F_
    auto f = *formulas_F_.begin();

    const auto op = f->get_operation_type();
    if(op == op_t::negation)
    {
        // F(~X) -> T(X)
        auto X = f->get_left_child_formula();
        if(X->is_constant())
        {
            // T(F) is not satisfiable
            if(X->is_constant_false())
            {
                return false;
            }
            // T(T) is satisfiable, continue with the rest
            return satisfiable_step();
        }
\end{lstlisting}
\newpage
\begin{lstlisting}
        if(find_in_F(X))
        {
            // Contradiction, we want to satisfy T(X)
            // but we already have to satisfy F(X).
            return false;
        }
        // We will add T(X) where X might be Contact or =0 term,
        // so we need to verify that we will not break the contact rule.
        if(has_broken_contact_rule(X))
        {
            return false;
        }

        if(find_in_T(X)) // skip adding it multiple times
        {
            return satisfiable_step();
        }

        add_formula_to_T(X);
        auto res = satisfiable_step();
        remove_formula_from_T(X);
        return res;
    }

    if(op == op_t::disjunction)
    {
        // F(X v Y) -> F(X) & F(Y)
        F_disjunction_child X(*this, f->get_left_child_formula());
        F_disjunction_child Y(*this, f->get_right_child_formula());

        // Checks that X does not bring a contradiction
        if(!X.validate())
        {
            return false;
        }
        X.add_to_F();

        if(!Y.validate())
        {
            X.remove_from_F();
            return false;
        }
        Y.add_to_F();

        auto res = satisfiable_step();

        X.remove_from_F();
        Y.remove_from_F();

        return res;
    }

\end{lstlisting}
\newpage
\begin{lstlisting}
    assert(op == op_t::conjunction);
    // F(X & Y) -> F(X) v F(Y)
    auto X = f->get_left_child_formula();
    auto Y = f->get_right_child_formula();

    trace() << "Will split to two subtrees: " << *X << " and " << *Y;

    // F(F) is satisfiable and we can skip the other branch
    if(X->is_constant_false() || Y->is_constant_false())
    {
        trace() << "One of the childs is constant false";
        return satisfiable_step();
    }

    auto process_F_conj_child = [&](const formula* child) {
        if(child->is_constant_true() || // F(T) is not satisfiable
           find_in_T(child))
        {
            return false;
        }
        if(find_in_F(child)) // skip adding it multiple times
        {
            return satisfiable_step();
        }

        add_formula_to_F(child);
        const auto res = satisfiable_step();
        remove_formula_from_F(child);
        return res;
    };

    trace() << "Start of the left subtree: " << *X << " of " << *f;
    if(process_F_conj_child(X))
    {
        // There was no contradiction in left path,
        // so there is no need to continue with the right path.
        return true;
    }

    trace() << "Start of the right subtree: " << *Y << " of " << *f;
    return process_F_conj_child(Y);
}
\end{lstlisting}

	\newpage
	\section{Model Implementation}

	\subsection{Modal point representation}
	The modal points are variable evaluations. The variables are converted to  identificators from 0 to N - 1, where N is the number of different boolean variables. The variable evaluation is a sequence of N 1s and 0s. Thus, all different evaluations are $2^N$. It is implemented via the \textit{boost::dynamic\_bitset}. Which is an optimized vector of N booleans. The memory for N elements is roughfly N bits. The element at position X is the evaluation for the variable with identificator X. 

	There might be variables in the formula which are not used in the branch conjunction. The evaluations for those variables are not needed. So, the variable evaluations will be only over the \textbf{used variables}. Let the used variables count is K. Then, all different modal points will be $2^K$.

	It is crucial to have an iterative algorithm for generating all modal points. The modal point representation is similar to the binary numbers. Therefore, the plus one binary operation is simulated over the bitset. It allows a generation of the next modal point. It is convenient for the model construction.

	The following is the implementation of the variable evaluation:
\newpage
\begin{lstlisting}
using variables_mask_t = boost::dynamic_bitset<>;
using variables_evaluations_t = boost::dynamic_bitset<>;
using set_variables_ids_t = std::vector<size_t>;

class variables_evaluations_block {
public:
    variables_evaluations_block(const variables_mask_t& variables);

    auto get_variables() const -> variables_mask_t;
    auto get_evaluations() -> variables_evaluations_t&;
    auto get_evaluations() const -> const variables_evaluations_t&;

    auto get_set_variables_ids() const -> const set_variables_ids_t&;
    auto generate_next_evaluation() -> bool;
    void reset_evaluations();

private:
    void init();

    variables_mask_t variables_;
    variables_evaluations_t evaluations_;

    // Caching the set variables.
    // For generating the next evaluations in order to make it
    // O(|set varaibles|) instead of O(|all variables in the mask|)
    set_variables_ids_t set_variables_ids_;
};
\end{lstlisting}
\newpage
\begin{lstlisting}
...
auto variables_evaluations_block::generate_next_evaluation() -> bool
{
    if((variables_ & evaluations_) == variables_)
    {
        // If the evaluation for the variables is only 1s
        // then we cannot generate a new one,
        // i.e. we have already generated all of them.
        return false;
    }

    /*
     * Will generate the evaluations in the following order:
     * 0...00, 0...01, 0...10, ... , 11...10, 11...11.
     * This is very similar to the increment(+1) operation of integer
     * numbers in their binary representation.
     * For the binary number an algorithm could be the following:
     * Iterate all bits starting from the least significant.
     *     - bit(i) == 1 => bit(i) = 0
     *     - bit(i) == 0 => bit(i) = 1 & stop
     * In our case it is similar, we want to make the increment
     * operation only on the set bits in the variables_ mask.
     * set_variables_ids_ has the ids of the set bits
     * in the variables mask in reverce order.
     */
    for(const auto id : set_variables_ids_)
    {
        if(!evaluations_[id])
        {
            evaluations_.set(id);
            break;
        }
        else
        {
            evaluations_.set(id, false);
        }
    }

    return true;
}
\end{lstlisting}

	\subsection*{Tableaux branch output}
	\label{tableaux:branch:output}
	As stated above the ouput of a branch in the tableaux process is a set of atomic formulas. These atomic formulas are grouped in six sets:
	\begin{itemize}
		\item Contacts ($contacts\_T$)
		\item Non Contacts ($contacts\_F$)
		\item Equal to Zero Terms ($zero\_terms\_T$)
		\item Not Equal to Zero Terms ($zero\_terms\_F$)
		\item Meassured Equal to Zero Terms ($measured\_less\_eq\_T$)
		\item Meassured Not Equal to Zero Terms ($measured\_less\_eq\_F$)
	\end{itemize}

	All atomic formulas in the branch should be satisfied. So, they are in a conjunction. Can be represented with the following formula:
	\begin{align*}
		\bigwedge\nolimits_{i} \; C(a_i, b_i) \:\: \wedge \:\: &
		\bigwedge\nolimits_{j} \; \neg C(e_j, f_j) \:\: \wedge \:\: \\
		\bigwedge\nolimits_{k} \; d_k = 0 \:\: \wedge \:\: &
		\bigwedge\nolimits_{l} \; g_l \neq 0 \:\: \wedge \:\: \\
		\bigwedge\nolimits_{s} \; <=_m(H_s, O_s) \:\: \wedge \:\: &
		\bigwedge\nolimits_{u} \; \neg (<=_m(Q_u, R_u) )
	\end{align*}

	\subsection*{Model output}
	\label{tableaux:branch:output}
	The model bulding produces the following collections:

	TODO: refactor, I do not like it that way...

	\begin{itemize}
		\item Vector of the modal points - $std::vector<variables_evaluations_block>$
		\item Connectivity matrix of the contacts between the points - $std::vector<model_points_set_t>$
		\item The evaluations for each boolean variable - $std::vector<model_points_set_t>$
	\end{itemize}

	\newpage
	\section{Connected Contact Logics Implementation}

	\iffalse
	TODO:
	Model:
	1) modal point representation
	2) connectivity matrix
	3) calculate_the_model_evaluation_of_each_variable - which points participates in the variable evaluation collection
	4) 1 and 2 and 3 are the output of the model.
	5) construct_contact_model_points
	6) construct_non_zero_model_points

	Connected model:
	7) construct_all_valid_unique_points
	8) reuse calculate_the_model_evaluation_of_each_variable
	9) is_zero_terms_F_rule_satisfied
	10) is_contacts_T_existence_rule_satisfied
	11) build_contact_relations_matrix
    Now, we have in some sence the biggest model(w.r.t number of unique points and maximal contact relations between them)
    12) get_connected_components
    13) reduce_variable_evaluations_to_subset_of_points
    14) reduce_model_to_subset_of_points

	TODOs:
	 - inductive def. for structures, e.g. terms
	 - recursive for functions
	 - R is reflexive and symetric - somewhere to mention it.

	\fi

	\newpage
	TODO: separate line for the authors
	\begin{thebibliography}{9}
		\bibitem{Handbook-of-Tableau-Methods}
			Handbook of Tableau Methods
			M. DAgostino, D. M. Gabbay, R. Hahnle and J. Posegga, eds.
		\bibitem{modal-logics-space}
			Modal Logics for Region-based Theories of Space
			Philippe Balbiani, Thinko Tinchev, Dimiter Vakarelov
		\bibitem{connected-space}
			\href{https://en.wikipedia.org/wiki/Connected_space}{Connected Space}
			or go to the next url: \url{https://en.wikipedia.org/wiki/Connected_space}
	\end{thebibliography}
\end{document}
