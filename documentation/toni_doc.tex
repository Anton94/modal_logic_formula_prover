\documentclass{article}

\usepackage{algorithm2e}
\usepackage[noend]{algpseudocode}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{systeme}
\usepackage{newtxtext}
\usepackage{newtxmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{array}
\usepackage{makecell}
\usepackage{booktabs}% http://ctan.org/pkg/booktabs
\usepackage{float}
\usepackage{hyperref}
\usepackage{tikz}

\SetKw{KwBy}{by}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}
\algnewcommand{\algorithmicgoto}{\textbf{go to}}%
\algnewcommand{\Goto}[1]{\algorithmicgoto~\ref{#1}}

\usetikzlibrary{arrows.meta}

\restylefloat{table}
\newcommand{\tabitem}{~~\llap{\textbullet}~~}

\newcommand\eqdef{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\scriptsize\sffamily def}}}{=\joinrel=}}}

\newcommand\M{\mathcal{M}}
\newcommand\F{\mathcal{F}}
\newcommand\p{\mathcal{P}}
\newcommand\V{\mathcal{V}}
\newcommand\E{\mathcal{E}}
\newcommand\VXi{X_i}
\newcommand\VX{X}
\newcommand\Tn{\mathcal{T}_n}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{defn}[theorem]{Deffinition}
\newcommand{\BranchConjunction}{%
\begin{alignat}{2}
			\bigwedge_{i=1}^{I} \; C(a_i, b_i) \:\: \wedge \:\: &
			\bigwedge_{j=1}^{J} \; d_j \neq 0 \:\: \wedge \:\:
			\bigwedge_{k=1}^{K} \; \neg C(e_k, f_k) \:\: \wedge \:\: &
			\bigwedge_{l=1}^{L} \; g_l = 0 \:\:
\end{alignat}%
}


\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\title{Satisfiability Of Connected Contact Logics}
\date{2019-9-28}
\author{Anton Dudov}

\begin{document}
	\maketitle
	\newpage

	\tableofcontents

	\newpage

	\section{Tableau Method For Classic Propositional Logic}

	\subsection{What Is A Tableau?}
	A tableau method is a formal proof procedure. First, it could be used as a refutation procedure: to show a formula X is valid we begin with some syntactical expression intended to assert it is not. This expression is broken down syntactically, generally splitting things into several cases. This part of a tableau procedure - the tableau expansion stage - can be thought of as a generalization of disjunctive normal form expansion. Generally, it moves from formulas to subformulas. Finally, there are rules for closing cases: impossibility conditions based on syntax. If each case closes, the tableau itself is said to be closed. A closed tableau beginning with an expression asserting that X is not valid is a tableau proof of X. \par	
	There is a second way of thinking about the tableau method: as a search procedure for models meeting certain conditions. Each branch of a tableau can be considered to be a partial description of a model. In automated theorem-proving, tableaus can be used to generate counter-examples. \par	
	The connection between the two roles for tableaus - as a proof procedure and as a model search procedure - is simple. If we use tableaus to search for a model in which X is false, and we produce a closed tableau, no such model exists, so X must be valid.

	\subsection{Classical Propositional Tableaus}
	We will look into the signed tableau system for classical propositional logic.

	\par
	First, we need syntactical machinery for asserting the invalidity of a formula, and for doing case analysis. For this purpose two signs are introduced: $T$ and $F$, where these are simply two new symbols, not part of the language of formulas. \textit{Signed formulas} are expressions of the form $F X$ and $T X$, where X is a formula. The intuitive meaning of $F X$ is that X is \textit{false} (in some model). Similarly, $T X$ intuitively asserts that X is \textit{true}. Then $F X$ is the syntactical device for (informally) asserting the invalidity of X. A tableau proof of X begins with $F X$.

	\par
	Next, we need machinery (rules) for breaking signed formulas down and doing a case division. We will define rules for each logical operator ($\neg \land \lor \Rightarrow \Leftrightarrow$).

	\par
	The treatment of \textbf{negation} is straightforward: from \textit{T $\neg$X} we get \textit{F X} and from \textit{F $\neg$X} we get \textit{T X}. These rules can be conveniently presented as follows.

	\[
		\frac{T \neg X}{F X}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\ \frac{F \neg X}{T X}
	\]

	\par

	The rules for \textbf{conjunction} are somewhat more complex. From truth tables we know that if $X \land Y$ is \textit{true}, X must be \textit{true} and Y must be \textit{true}. Likewise, if $X \land Y$ is \textit{false}, eigher X is \textit{false} or Y is \textit{false}. This involves a split into two cases. Corresponding syntactic rules are as follows.
	\[
		\frac{T X \land Y}{\displaystyle{T X \atop T Y}}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\ \frac{F X \land Y}{F X \mid F Y}
	\]

	The rules for \textbf{disjunction} are similar. From truth tables we know that if $X \lor Y$ is \textit{true}, eigher X is \textit{true} or Y is \textit{true}. This involves a split into two cases. Likewise, if $X \lor Y$ is \textit{false}, X must be \textit{false} and Y must be \textit{false}. Corresponding syntactic rules are as follows.
	\[
		\frac{T X \lor Y}{T X \mid T Y}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\ \frac{F X \lor Y}{\displaystyle{F X \atop F Y}}
	\]

	\par
	The rules for \textbf{implication}. From truth tables we know that if $X \Rightarrow Y$ is \textit{true}, eigher X is \textit{false} or Y is \textit{true}. Likewise, if $X \Rightarrow Y$ is \textit{false}, X must be \textit{true} and Y must be \textit{false}. Corresponding syntactic rules are as follows.
	\[
		\frac{T X \Rightarrow Y}{F X \mid T Y}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\ \frac{F X \Rightarrow Y}{\displaystyle{T X \atop F Y}}
	\]

	\par
	The rules for \textbf{equivalence}. From truth tables we know that if $X \Leftrightarrow Y$ is \textit{true}, eigher X is \textit{true} and Y is \textit{true} or X is \textit{false} and Y is \textit{false}. Likewise, if $X \Rightarrow Y$ is \textit{false}, eigher X is \textit{true} and Y is \textit{false} or X is \textit{false} and Y is \textit{true}. Corresponding syntactic rules are as follows.
	\[
		\frac{T X \Leftrightarrow Y}{\left.\displaystyle{T X \atop T Y}\right\vert\displaystyle{F X \atop F Y}}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\ \frac{F X \Leftrightarrow Y}{\left.\displaystyle{T X \atop F Y}\right\vert\displaystyle{F X \atop T Y}}
	\]

	\par
	The standard way of displaying tableaus is as downward branching trees with signed formulas as node labels. Indeed, the tableau method is often referred to as the tree method. Think of a tree as representing the disjunction of its branches, and a branch as representing the conjunction of the signed formulas on it.

	\par
	When using a tree display, a tableau expansion is thought of temporally, and one talks about the stages of constructing a tableau, meaning the stages of growing a tree. The rules given above are thought of as branch-lengthening rules. Thus, a branch containing \textit{T $\neg$ X} can be lengthened by adding a new node to its end, with \textit{F X} as a label. Likewise a branch containing \textit{F X $\lor$ Y} can be lengthened with two new nodes, labelled \textit{F X} and \textit{F Y} (take the node with \textit{F Y} as the child of the one labelled \textit{F X}). A branch containing \textit{T X $\lor$ Y} can be split - its leaf is given a new left and a new right child, with one labelled \textit{T X}, the other \textit{T Y}. This is how the schematic rules above are applied to trees.
	\par
	An important point to note is that the tableau rules are non-deterministic. They say what can be done, not what must be done. At each stage, we choose a signed formula occurrence on a branch and apply a rule to it. Since the order of choice is arbitrary, there can be many tableaus for a single signed formula.
	\par
	Here is the final stage of a tableau expansion beginning with the signed formula $F (X \land Y) \Rightarrow (\neg X \land \neg Y)$.
	\\\indent\indent\indent\indent 1. $F(X \land Y) \Rightarrow \neg(\neg X \lor \neg Y)$
	\\\indent\indent\indent\indent 2. $TX \land Y$
	\\\indent\indent\indent\indent 3. $F\neg(\neg X \lor \neg Y)$
	\\\indent\indent\indent\indent 4. $T X$
	\\\indent\indent\indent\indent 5. $T Y$
	\\\indent\indent\indent\indent 6. $T\neg X \lor \neg Y$
	\\
	\begin{tikzpicture}[scale = 0.8]
		\draw (-4,0) (4,1);
        \draw[thick] (-1.5,0) -- (0,1) -- (1.5,0);
    \end{tikzpicture}
	\\\indent\indent\;\;  7. $T \neg X$  \indent \indent\indent 8. $T \neg Y$
	\\\indent\indent\;\; 9. $F X$ \indent\indent\indent 10. $F Y$

	\par
	In this we have added numbers for reference purposes. Items 2 and 3 are from 1 by $F \Rightarrow $. 4 and 5 are from 2 by $T \land$. 6 is from 3 by $F \neg$. 7 and 8 are from 6 by $T \lor$. 9 is from 7 by $T \neg$. 10 is from 8 by $T \neg$.
	\par
	Finaly, the conditions for closing off a case (declaring a branch closed) are	simple. A \textbf{branch is closed} if it contains a contradiction, i.e. $T A$ and $F A$ for some formula $A$. A \textbf{branch is opened} if it does not contain any contradiction. If each branch is closed, then the \textbf{tableau is closed}. A closed tableau for $F X$ is a tableau proof of $X$, meaning that A is a tautology. The tableau displayed above is closed, so the formula $(X \land Y) \Rightarrow (\neg X \land \neg Y)$ has a tableau proof.
	\par
	It may happen that no tableau proof is forthcoming, and we can think of the tableau construction as providing us with contraexamples. Consider the following attempt to prove $(X \Rightarrow Y) \Rightarrow ((Y \Rightarrow X) \Rightarrow \neg Y)$
	\\\indent\indent\indent\indent\indent\indent 1. $F (X \Rightarrow Y) \Rightarrow ((Y \Rightarrow X) \Rightarrow \neg Y)$
	\\\indent\indent\indent\indent\indent\indent 2. $T X \Rightarrow Y$
	\\\indent\indent\indent\indent\indent\indent 3. $F (Y \Rightarrow X) \Rightarrow \neg Y$
	\\\indent\indent\indent\indent\indent\indent 4. $T Y \Rightarrow X$
	\\\indent\indent\indent\indent\indent\indent 5. $F \neg Y$
	\\\indent\indent\indent\indent\indent\indent 6. $T Y$
	\\
	\begin{tikzpicture}[scale = 0.8]
		\draw (-5,0) (5,1);
        \draw[thick] (-2,0) -- (-0.4,1) -- (1.6,0);
    \end{tikzpicture}
	\\\indent\indent\indent 7. $F X$  \indent\indent\indent\indent\;\; 8. $T Y$
	\\
	\begin{tikzpicture}[scale = 0.8]
		\draw (-5,0) (5,1);
        \draw[thick] (-3.2,0) -- (-2.3,1) -- (-1.4,0);
        \draw[thick] (1,0) -- (2,1) -- (3,0);
    \end{tikzpicture}
	\\\indent\;\; 9. $F Y$ \indent 10. $T X$  \indent 11. $F Y$ \indent 12. $T X$
	\par
	Item 2 and 3 are from 1 by $F \Rightarrow$, as are 4 and 5 from 3. Item 6 is from 5 by $F \neg$. Items 7 and 8 are from 2 by $T \Rightarrow$, as are 9 and 10 from 4. Items 11 and 12 are also from 4 by $T \Rightarrow$. The leftmost branch is closed because of 6 and 9. The left-right branch is closed because of 7 and 10. The right-left branch is closed because of 8 and 11. But the rightmost branch is not closed. Notice that every non-atomic signed formula has had a rule applied to it on this branch and there is nothing left to do. (For clasical propositional logic it is sufficient to apply a rule to a formula on a branch only once.) In fact the branch yields a counterexample, as follows. Let $\upsilon$ be a propositional valuation that maps X to \textit{true} and Y to \textit{true} in accordance to 8 and 12. Now, we work our way back up the branch. Since $\upsilon(Y) = true$, $\upsilon(\neg Y) = false$, item 5. From $\upsilon(X) = true$ follows that $\upsilon(Y \Rightarrow X) = true$, item 4. From $\upsilon(Y) = true$ follows that $\upsilon(X \Rightarrow Y) = true$, item 2. Since $\upsilon(Y \Rightarrow X) = true$ and $\upsilon(\neg Y) = false$ we have $\upsilon((Y \Rightarrow X) \Rightarrow \neg Y) = false$, item 3. Finally, $\upsilon((X \Rightarrow Y) \Rightarrow ((Y \Rightarrow X) \Rightarrow \neg Y)) = false$, item 1.
	\par
	Later, we are going to use the tableau method to produce a model in which the initial formula is valid.
	\par
	From a different point of view, we can think of a classical tableau simply as a set of sets of signed formulas: a tableau is the set of its all branches, and a branch is the set of signed formulas that occur on it. Semantically, we think of the outer set as the disjunction of its members, and these members, the inner sets, as conjunctions of signed formulas they contain. Considered this way, a tableau is a generalization of disjunctive normal form (a generalization because of formulas more complex than literals can occur). Now, the tableau construction process can be thought of as a variation of the process of converting a formula into a disjunctive normal form. 	

	\newpage
	\section{Contact Logics}
	\subsection{Syntax}
	The language of contact logic consist of:
	\begin{itemize}
		\item \textit{Boolean variables} (a denumeratable set $\V$)
		\item \textit{Boolean constants}: 0 and 1
		\item \textit{Boolean operations}:
		\begin{itemize}
			\item $\sqcap$ boolean meat
			\item $\sqcup$ boolean join
			\item $^*$ boolean complement
		\end{itemize}
		\item \textit{Boolean terms} (or simply \textit{terms})
		\item \textit{Propositional connectivies}: $\neg$, $\land$, $\lor$, $\Rightarrow$, $\Leftrightarrow$
		\item \textit{Propositional constants}: $\top$ and $\bot$
		\item \textit{Modal connectives}: $\leq$(part-of) and $C$(contact)
		\item \textit{Complex formulas} (or simply \textit{formulas})
	\end{itemize}

	\noindent\textbf{\textit{Terms}} are defined in the following inductive process:
	\begin{itemize}
		\item Each Boolean variable is a term
		\item Each Boolean constant is a term
		\item If $a$ is a term then $a^*$ is a term
		\item If $a$ and $b$ are terms then $a \sqcap b$ and $a \sqcup b$ are terms
	\end{itemize}

	\noindent\textbf{\textit{Atomic formulas}} are of the form $a \leq b$ and $aCb$, where $a$ and $b$ are terms.

	\noindent\textbf{\textit{Formulas}} are defined in the following inductive process:
	\begin{itemize}
		\item Each propositional constant is a formula
		\item Each atomic formula is a formula
		\item If $\phi$ is a formula then $\neg\phi$ is a formula
		\item If $\phi$ and $\psi$ are formulas then ($\phi \land \psi$), ($\phi \lor \psi$), ($\phi \Rightarrow \psi$) and ($\phi \Leftrightarrow \psi$) are formulas
	\end{itemize}

	\noindent\textbf{\textit{Abbreviations}}:
		$a = b \eqdef (a \leq b) \land (b \leq a)$,
		$a \nleq b \eqdef \neg(a \leq b)$,
		$a \neq b \eqdef \neg(a = b)$

	\subsection{Relational semantics}
	\label{relational-system}

	\par
	Let $\F$ = (W, R) be a relational system with W $\neq$ $\emptyset$ and R $\subseteq$ $W^2$. We call such systems \textit{frames}. Following Galton[TODO] we may give a spatial meaning of frames naming the elements of W, \textit{cells} and the relation R, \textit{adjacency relation}. Then $\F$ is called \textit{adjacency space}. An example of adjacency space is the chess-board table, the cells are the squares, and two squares are adjacent if they have a common point.

	\par
	Originally Galton assumed R to be a reflexive and symmetric relation but it is more natural for R to be an arbitrary relation. \textit{Regions} in an adjacency space are arbitrary subsets of W and two sets $a$ and $b$ are in \textit{contact} ($aC_Rb$) if for some $x \in a$ and $y \in b$ we have $xRy$. Another way to define this relation is the following. For a subset $a \subseteq W$ define as in modal logic $\langle R \rangle a = \{ x \in W : (\exists y \in W)(xRy$ and $y \in a)\}$. Then $aC_Rb$ iff $a \cap \langle R \rangle b \neq \emptyset$ iff $\langle R^{-1} \rangle a \cap b \neq \emptyset$, where $R^{-1}$ is the converse relation of R. Note that if R is a symmetric relation then $aCb$ iff $a \cap \langle R \rangle b \neq \emptyset$ iff $\langle R \rangle a \cap b \neq \emptyset$.

	\begin{defn}
		\label{valuation}
		By a \textbf{\textit{valuation}} of the Boolean variables in $\F$ we mean any function $\upsilon : \V \rightarrow \p(W)$ assigning to each Boolean variable $b$ a subset $\upsilon(b) \subseteq W$. The valuation $\upsilon$ is then extended inductively to all Boolean terms as follows:

		\begin{itemize}
			\item $\upsilon(0) = \emptyset$
			\item $\upsilon(1) = W$
			\item $\upsilon(a \sqcap b) = \upsilon(a) \cap \upsilon(b)$
			\item $\upsilon(a \sqcup b) = \upsilon(a) \cup \upsilon(b)$
			\item $\upsilon(a^*) = W \setminus \upsilon(a) = -\upsilon(a)$
		\end{itemize}
	\end{defn}

	\begin{defn}
		The pair $\M$ = ($\F, \upsilon$) is called \textbf{\textit{model}}. The truth of a formula $\phi$ in $\M$ ($\M \models \phi$ or $\F, \upsilon \models \phi$) is extended inductively to all Boolean terms as follows:
		\begin{itemize}
			\item For atomic formulas:
				\begin{itemize}
					\item $\M \models \top$
					\item $\M \not\models \bot$
					\item $\M \models a \leq b \iff \upsilon(a) \subseteq \upsilon(b)$
					\item $\M \models aCb \iff \upsilon(a)$ $C_R$ $\upsilon(b$ $\iff (\exists x \in \upsilon(a))(\exists y \in \upsilon(b))(xRy)$
				\end{itemize}
			\item For complex formulas:
				\begin{itemize}
					\item $\M \models \neg \phi \iff \M \not\models \phi$
					\item $\M \models \phi \land \psi \iff \M \models \phi$ and $\M \models \psi$
					\item $\M \models \phi \lor \psi \iff \M \models \phi$ or $\M \models \psi$
					\item $\M \models \phi \Rightarrow \psi \iff \M \not\models \phi$ or $\M \models \psi$
					\item $\M \models \phi \Leftrightarrow \psi \iff$ ($\M \models \phi$ and $\M \models \psi$) or ($\M \not\models \phi$ and $\M \not\models \psi$)
				\end{itemize}
		\end{itemize}
	\end{defn}
	\par
	Let us note that in the above semantics we evaluate formulas not locally at points[ TODO ??], as it is in the standard modal semantics, but globally in the whole model and this is one of the main differences of the present modal approach with the standard Kripke approach.

	\begin{defn}
		A model $\M$ is a \textit{\textbf{model of a formula}} $\phi$ if $\phi$ is \textit{true} in $\M$.
	\end{defn}

	\begin{defn}
		If $\phi$ has a model $\M$, then $\phi$ is \textbf{satisfiable}.
	\end{defn}

	\begin{defn}
		$\M$ is a \textbf{model of a set of formulas} $A$ if $\M$ is a model of all formulas from A.
	\end{defn}

	\begin{defn} A formula $\phi$ \textbf{is \textit{true}} (or \textbf{valid}) in a frame $\F$ ($\F \models \phi$), if $\M \models \phi$ for all models $\M$ based on $\F$, i.e. for all valuations $\upsilon$ we have $\F$,$\upsilon \models \phi$.
	\end{defn}

	\begin{lemma}
		(Equality of formulas) Let f and g are formulas. Then \par $f = g \implies \upsilon(f) = \upsilon(g)$.
	\end{lemma}

	\begin{lemma}
		(Equality of terms) Let a and b are terms. Then \par $a = b \implies \upsilon(a) = \upsilon(b)$.
	\end{lemma}

	\begin{lemma} (Zero term) Let a and b are terms. Then \par $a \leq b \implies a \sqcap b^*=0$
	\end{lemma}

	\begin{lemma} (Non-zero term) Let a and b are terms. Then \par $\neg(a \leq b) \implies a \sqcap b^* \neq 0$
	\end{lemma}

	TODO: axiom or lemma or neither??
	\begin{axiom}
		(Reflexivity) Let a be a term. Then \par $ a \neq 0 \implies aCa$.
	\end{axiom}

	\begin{axiom}
		(Symmetry) Let a and b are terms. Then \par $aCb \iff bCa$.
	\end{axiom}

	\begin{lemma}
		(Monotonicity) Let a and b are terms. Then \par $aCb \land a \leq a' \land b \leq b' \implies a'Cb'$.
	\end{lemma}

	\begin{lemma}
		(Distributivity) Let a and b are terms. Then \par $aC(b \sqcup c) \iff aCb \lor aCc$, \; TODO what is the other one? $aC(b \sqcup c) \iff aCb \lor aCc$.
	\end{lemma}

	\begin{lemma}
		Let a, b, c are terms and f, g are formulas. The following formulas are true:
		\begin{itemize}
			\item $f \land T \implies f$, $T \land f \implies f$
			\item $f \land F \implies F$, $F \land f \implies F$
			\item $f \lor T \implies T$, $T \lor f \implies T$
			\item $f \lor F \implies f$, $F \lor f \implies f$
			\item $a \sqcap 0 \implies 0$, $0 \sqcap a \implies 0$
			\item $a \sqcup 0 \implies a$, $0 \sqcup a \implies a$
			\item $a \sqcap 1 \implies a$, $1 \sqcap a \implies a$
			\item $a \sqcup 1 \implies 1$, $1 \sqcup a \implies 1$
			\item $(a \sqcup b)Cc \iff aCc \lor bCc$
			\item $(a \sqcup b) \leq c \iff a \leq c \land b \leq c$
			\item $aCb \implies a \neq 0 \land b \neq 0$
			\item $a \sqcap b \neq 0 \implies aCb$
			\item $a = 0 \lor b = 0 \implies \neg(aCb)$
			\item $0 \leq a \implies T$
			\item $a \leq 1 \implies T$
			\item $0C0 \implies F$
			\item $aC0 \implies F$
			\item $1C1 \implies T$
			\item $aC1 \implies a \neq 0$
			\item $a \neq 0 \implies aCa$
		\end{itemize}
	\end{lemma}

	\subsection{Formula satsfiability}
		Let $\psi$ be a propositional formula. Let us build a tableau beginning with $\psi$. If the tableau has an opened branch then $\psi$ is satisfiable. Unfortunately, for the contact logic this is not enough because we need to verify the modal connectives ($\leq$ and $C$).
		\paragraph{}
		Let $\phi$ be a formula. Let us build a tableau beginning with $\phi$. Let the tableau has an opened branch $B$. The branch $B$ is a set of signed atomic formulas of the following type:
		\begin{itemize}
			\item $T C(a,b)$
			\item $F C(e,f)$
			\item $T a \leq b$
			\item $F a \leq b$
		\end{itemize}
		where a and b are terms.

		\noindent $B$ is an opened branch, so there are no contradicting formulas in it, i.e. $(\neg \exists X)(T X \in B \land F X \in B)$.
		The signed atomic formulas could be written as atomic formulas as follows:
		\begin{itemize}
			\item $T C(a,b)$ $\rightarrow$ $C(a,b)$
			\item $F C(a,b)$ $\rightarrow$ $\neg C(a,b)$
			\item $T a \leq b$ $\rightarrow$ $a \leq b$ $\rightarrow$ $a \sqcap b^*=0$ $\rightarrow$ $g = 0$ (zero term)
			\item $F a \leq b$ $\rightarrow$ $\neg (a \leq b)$ $\rightarrow$ $a \sqcap b^* \neq 0$ $\rightarrow$ $d \neq 0$ (non-zero term)
		\end{itemize}
			\noindent where a,b,d and g are terms.

		All atomic formulas in the branch should be satisfied, so we can think of it as a conjunction of them. Let's call it a \textbf{branch conjunction}. It is sufficient to build a satisfiable model for the branch conjuction to verify that $\phi$ is satisfiable. Building  such a model could be done a lot more effective than building a model for an arbitrary formula because it is just a conjuction.
		\begin{defn}
			\label{branch-conjunction}
			Let $\phi$ be a formula. Let T be a tableau beginning with $\phi$. Let B be a set of all atomic signed formulas in a branch of T, as follows:
			\begin{alignat}{2}
				B = \{T C(a_i, b_i) \mid i \in \{1, \ldots, I\} \} \cup
					\{F d_j = 0 \mid j \in \{1, \ldots, J\} \} \cup \\\nonumber
					\{F C(e_k, f_k) \mid k \in \{1, \ldots, K\} \} \cup
					\{T g_l = 0 \mid l \in \{1, \ldots, L\} \}
			\end{alignat}
		\end{defn}
		A \textbf{branch cojnuction} $\beta$ is the following formula:
		 \BranchConjunction

	\subsection{Branch conjunction model building}
		The branch conjunction formula $\beta$ is satisfiable if $\beta$ has a model $\M$. We have to construct such a model $\M$ = ($\F, \upsilon$) = ((W, R), $\upsilon$). 
		\begin{defn}
			A denumeratable set of $n$ boolean variables $\V_n$ is defined as follows:
			\begin{equation}
				\label{boolean-evaluation}
				\V_n = \{x_1, x_2, \ldots , x_n \}
			\end{equation}
		\end{defn}
		Let n be the number of the unique boolean variables in $\beta$. Let $\V_n$ be the set of them. Out of the four types of atomic formulas in $\beta$ only two require existance of modal points. These are the contacts and non-zero terms. The valuation $\upsilon$ should assign a set of modal points to each boolean variable $x \in \V_n$. One way to define $\upsilon$ and W is the following: 
		
		\begin{itemize}
			\item Assign an empty set of modal points for each boolean variable $x \in \V_n$.
	
			$\upsilon$ = \{ <x, $\emptyset$> $\mid$ $ x \in \V_n$ \}
			
			\item Add a modal point for each term in the contacts and non-zero terms of $\beta$. 
			
			W = \{ $p_i$ $\mid$ C($a_i$, $b_i$) $\in$ $\beta$ \} $\cup$ \{ $p_{I+i}$ $\mid$ C($a_i$, $b_i$) $\in$ $\beta$ \} $\cup$ \{ $p_{I*2+j}$ $\mid$ $d_j \neq 0$ $\in$ $\beta$ \}
						
			\item Extend $\upsilon$ such as:
			
			\begin{itemize}
				\item $p_i$ $\in$ $\upsilon(a_i)$ for each C($a_i$, $b_i$) $\in$ $\beta$ 
				\item $p_{I+i}$ $\in$ $\upsilon(b_i)$ for each C($a_i$, $b_i$) $\in$ $\beta$ 
				\item $p_{I*2+j}$ $\in$ $\upsilon(d_j)$ for each $d_j$  $\neq$ 0 $\in$ $\beta$ 
			\end{itemize}
		\end{itemize}
				
		\begin{defn}
			Let $\V_n$ be a denumeratable set of $n$ boolean variables. Let W be a set of modal points. Let $\upsilon$ be a valuation over $\V_n$ and W. Then $\VXi$ $\subseteq$ W is the evaluation set of the boolean variable $x_i$ in $\V_n$.
			\begin{equation}
				\VXi = \upsilon(x_i) \;for x_i \in \V_n
			\end{equation}
		\end{defn}
		
		\begin{defn}
			Let $\V_n$ be a denumeratable set of $n$ boolean variables. Let W be a set of modal points. Let $\upsilon$ be a valuation over $\V_n$ and W. 
			Then $\VX$ is the union of all evaluations of boolean variables in $\V_n$.
			\begin{equation}
				\VX = \bigcup\limits_{x_i \in \V_n}\upsilon(x_i) = \bigcup\limits_{x_i \in \V_n}\VXi
			\end{equation}
		\end{defn}
		
		Let t be an arbitrary term. Let p $\notin$ W be a new modal point. Let us extend $\upsilon$ such as p $\in$ $\upsilon(t)$. By the valuation definition  $\upsilon(t)$ is a composition of interesections, unions and compliments of some $\VXi$ $\subseteq$ W. Therefore, the modal point p should be added to zero or more $\VXi$ depending on the boolean operations in the term t. With n boolean variables there are $2^n$ ways of adding the point p.
		
		
		
		\begin{defn}
			A \textbf{variable evaluation $\E_n$} for $n$ boolean variables is a sequence of 1s and 0s, as follows:
			\begin{equation}
				\E_n = \; < e_1, e_2, \ldots , e_n >, \; where \; e_1, \ldots, e_n \in \{0, 1 \}
			\end{equation}
		\end{defn}

		For $n$ boolean variables there are $2^n$ unique variable evaluations. We will define the modal points as variable evaluations. By the definition of the valuation, it is not possible to distinguish two or more different modal points in some subsets. For example, the W $\setminus$ $\VX$ subset. The modal point representation also have this limitaion. The modal connectives require existence of a point in those sets. It is sufficient to work with only one point from them.

		\begin{defn}
			Let $\E_n$ be a variable evaluation for $n$ boolean variables. Then $(\E_n)^i$ is the i-th element in the sequence $\E_n$.
		\end{defn}

		\begin{defn}
			Let $\V_n$ be a denumeratable set of $n$ boolean variables. The set of \textbf{all unique variable evaluations $W_n$} over $n$ variables is defined as follows:
			\begin{equation}
				\label{all-unique-points}
				W_n = \{< e_1, e_2, \ldots , e_n > \mid e_1, \ldots, e_n \in \{0, 1 \} \}
			\end{equation}
		\end{defn}

		\begin{defn}
			\label{valuation-modal-points}
			Let $\V_n$ be a denumeratable set of $n$ boolean variables. Let $W_n$ be the set of all unique points over n variables. Let W $\subseteq$ $W_n$. Then the \textbf{valuation $\upsilon_n : \V_n \rightarrow \p(W)$} is inductively defined as follows:
			\begin{itemize}
				\item Boolean constants
					\begin{itemize}
						\item $\upsilon_n(0) = \emptyset$
						\item $\upsilon_n(1) = W$
					\end{itemize}
				\item Boolean variables
					\begin{itemize}
						\item $\upsilon_n(x_i) = \{ \E_n \mid \E_n \in W \land (\E_n)^i = 1 \}$, for $x_i \in \V_n$
					\end{itemize}
				\item Boolean terms
					\begin{itemize}
						\item $\upsilon_n(a \sqcap b) = \upsilon_n(a) \cap \upsilon_n(b)$
						\item $\upsilon_n(a \sqcup b) = \upsilon_n(a) \cup \upsilon_n(b)$
						\item $\upsilon_n(a^*) = W \setminus \upsilon_n(a) = -\upsilon_n(a)$
					\end{itemize}
			\end{itemize}
		\end{defn}

		Let $\beta$ be a branch conjunction as in \ref{branch-conjunction} . Let W be a set of modal points. Let $\V_n$ be the set of boolean variables in $\beta$. Let $\upsilon_n$ be a valuation as in \ref{valuation-modal-points} . Let $W \subseteq W_n$. Let R $\subseteq$ $W^2$ be a reflexive and symetric relation.

		\begin{defn}
			The zero terms in $\beta$ are satisfied iff each zero term's valuation is the empty set.
			\begin{equation}
				(\forall (g_l = 0) \in \beta)(\upsilon_n(g_l) = \emptyset)
			\end{equation}
		\end{defn}

		\begin{defn}
			The non-contacts in $\beta$ are satisfied iff:
			\begin{equation}
				(\forall_{\neg C(e_k, f_k) \in \beta})\neg(\exists x \in \upsilon_n(e_k))(\exists y \in \upsilon_n(f_k))(xRy)
			\end{equation}
		\end{defn}

		\begin{lemma}
			The valuations of the non-contact terms in $\beta$ does not have a common modal point. Follows from the reflexivity of R.
			\begin{equation}
				(\forall_{\neg C(e_k, f_k) \in \beta})(\upsilon_n(e_k) \cap \upsilon_n(f_k) = \emptyset)
			\end{equation}
		\end{lemma}

		\begin{defn}
			Let t be an arbitrary boolean term. Then $\V_t$ is the set of the boolean variables used in t.
		\end{defn}

		\begin{defn}
			Let $\V_n$ be a denumeratable set of boolean variables. Then $\Tn$ is the set of all boolean terms with variables of $\V_n$.
			\begin{equation}
				\Tn = \{t \mid t \;is\; a \;boolean \;term \;and \;\V_t \subseteq \V_n \}
			\end{equation}
		\end{defn}

		\begin{defn}
			Let $\V_n$ be a denumeratable set of boolean variables. Let $\Tn$ be the set of all boolean terms with variables of $\V_n$. Let W $\subseteq$ $W_n$. By a \textbf{boolean valuation} of a boolean term in $\Tn$ we mean the function $\eta$. It assigns a boolean constant for each pair of term t $\in$ $\Tn$ and variable evaluation $\E_n \in W_n$.
			\begin{equation}
				\eta(t, \E_n) \in \{0, 1\}
			\end{equation}
			Let t $\in$ $\Tn$. Let $\E_n \in W_n$. The inductive definition of $\eta$ on the structure of the term t is as follows:
			\begin{itemize}
				\item $\eta(0, E_n) = 0$
				\item $\eta(1, E_n) = 1$
				\item $\eta(x_i, E_n) = (E_n)^i$		
				\item $\eta(a \sqcap b, E_n) = \eta(a, E_n) \sqcap \eta(b, E_n)$
				\item $\eta(a \sqcup b, E_n) = \eta(a, E_n) \sqcup \eta(b, E_n)$
				\item $\eta(a^*, E_n) = \;^*\eta(a, E_n)$
			\end{itemize}
		\end{defn}

		\begin{lemma}
			Let t $\in \Tn$ be an arbitrary term. Let W $\subseteq$ $W_n$. Let $\E_n$ $\in$ W. Let $\eta$ be a boolean valuation. Let $\upsilon_n$ be a valuation as in \ref{valuation-modal-points} . By the definition of $\eta$ and $\upsilon_n$ follows:
			\begin{equation}
				\eta(t, \E_n) = 1 \iff \E_n \in \upsilon_n(t)
			\end{equation}
		\end{lemma}

		\begin{defn}
			Let t $\in \Tn$ be an arbitrary term. Let $\eta$ be a boolean valuation. Let $\E_n$ $\in$ $W_n$. Then $\mathbf{\E_n \; satisfies \; t}$ iff $\E_n$ evaluates t to the constant 1.
			\begin{equation}
				\E_n \; satisfies \; t \iff \eta(t, \E_n) = 1
			\end{equation}
		\end{defn}

		\begin{defn}
			Let t $\in \Tn$ be an arbitrary term. Let $\eta$ be a boolean valuation. The set of all variable evaluations $\E_t$ which satisfies t is defined as follow:
			\begin{equation}
				\E_t = \{ \E_n \mid \E_n \in W_n \land \eta(t, \E_n) = 1 \}
			\end{equation}
		\end{defn}

		\begin{defn}
			Let $\E_n \in W_n$. Let W $\subseteq W_n$. Let W = $W \cup {\E_n}$. Then $\E_n$ is a $\mathbf{valid \; modal \; point \; of \; \beta}$ if it does not break the satisfaction of the zero terms and non-contacts in $\beta$:
			\begin{align*}
				(\forall (g_l = 0) \in \beta)(\E_n \notin \upsilon_n(g_l)) \land
				(\forall_{\neg C(e_k, f_k) \in \beta})(\E_n \notin \upsilon_n(e_k) \cap \upsilon_n(f_k)) \iff \\
				(\forall (g_l = 0) \in \beta)(\eta(g_l, \E_n) = 0) \land
				(\forall_{\neg C(e_k, f_k) \in \beta})(\eta(e_k, \E_n) = 0 \land \eta(f_k, \E_n) = 0)
			\end{align*}
		\end{defn}

		\begin{defn}\label{set-all-valid-modal-points}
			Let $W^v \subseteq W_n$ be the set of all valid modal points of $\beta$.
			\begin{equation}
				W^v = \{ \E_n \mid \E_n \in W_n \land \E_n \; is \; a \; valid \; modal \; point \; of \; \beta \}
			\end{equation}
		\end{defn}

		\begin{defn}
			Let x, y $\in W^v$. Then <x, y> is a $\mathbf{valid \; connected \; pair \; of \; \beta}$ modal points if it does not break the satisfaction of non-contacts in $\beta$.
			\begin{align*}
			(\forall_{\neg C(e_k, f_k) \in \beta})\neg(
			(x \in \upsilon_n(e_k) \land y \in \upsilon_n(f_k)) \:\lor \\
			(x \in \upsilon_n(f_k) \land y \in \upsilon_n(e_k)) \:\lor \\
			(x \in \upsilon_n(e_k) \land y \in \upsilon_n(e_k)) \:\lor \\
			(x \in \upsilon_n(f_k) \land y \in \upsilon_n(f_k))) \\ \:\iff \\
			(\forall_{\neg C(e_k, f_k) \in \beta})\neg(
			(\eta(e_k, x) = 1 \land \eta(f_k, y) = 1) \:\lor \\
			(\eta(f_k, x) = 1 \land \eta(e_k, y) = 1) \:\lor \\
			(\eta(e_k, x) = 1 \land \eta(e_k, y) = 1) \:\lor \\
			(\eta(f_k, x) = 1 \land \eta(f_k, y) = 1))
			\end{align*}
		\end{defn}

		\begin{defn}\label{set-all-valid-modal-point-pairs}
			Let $R^v \subseteq {W^v}^2$ be the set of all valid connected pairs of $\beta$ modal points.
			\begin{equation}
				R^v = \{ <x, y\> \mid x, y \in W^v \land <x, y> \; is \; a \; valid \; connected \; pair \; of \; \beta \; modal \; points\}
			\end{equation}
		\end{defn}

		\begin{lemma}\label{satisfied-contacts-non-zero-terms}
			Let $\F = (W^v, R^v)$ be a relational system. $\F$ satisfies the contacts and non-zero terms in $\beta$ iff:
			\begin{align*}
				(\forall (d_j \neq 0) \in \beta)(\exists \E_n \in W^v)(\E_n \in \upsilon_n(d_j)) \: \land \\
				(\forall_{C(a_i, b_i) \in \beta})(\exists <x, y> \in R^v)(x \in \upsilon_n(a_i) \land y \in \upsilon_n(b_i)) \\ \iff \\
				(\forall (d_j \neq 0) \in \beta)(\exists \E_n \in W^v)(\eta(d_j, \E_n) = 1 \: \land \\
				(\forall_{C(a_i, b_i) \in \beta})(\exists <x, y> \in R^v)(\eta(a_i, x) = 1 \land \eta(b_i, y) = 1)
			\end{align*}
		\end{lemma}

			Let $\F = (W^v, R^v)$. Let $\M = (\F, \upsilon_n)$. $\M$ satisfies the zero terms and non-contacts in $\beta$. $\M$ is a model of $\beta$ if the non-zero terms and contacts are satisfied \ref{satisfied-contacts-non-zero-terms} .

			The model $\M$ is not convenient. It might have a lot of modal points and connections between them. For example, let $\beta = C((x \sqcap y) \sqcap z, t \sqcup e)$. Then $\V_n = \{x, y, z, t, e\}$. There are no zero terms and non-contacts, so $W^v$ is the same as $W_n$. Therefore, $|W^v|= 32$ and $|R^v| = 32^2$.

	The following algorithm builds a more convenient model. Creates modal points and connections only for the non-zero and contact terms in $\beta$.

		\LinesNumbered
		\DontPrintSemicolon
		\begin{algorithm}
			$W \gets \emptyset$
			\;
			$R \gets \emptyset$
			\;
			\tcc{Process the non-zero terms in $\beta$}
			\For{$d_j \neq 0 \in \beta$}{\label{non-zero-terms}
				\For{$\E_n \in W^v$}{
					\uIf{$\eta(d_j, \E_n) = 1$}{
						$W \gets W \cup \{ x \}$
						\;
						$R \gets R \cup \{ <x,x> \}$
						\;
						\Goto{non-zero-terms}
					}
				}
				Unable to construct a model.
			}
			\tcc{Process the contacts in $\beta$}
			\For{$C(a_i, b_i) \in \beta$}{\label{contacts}
				\For{$<x, y> \in R^v$}{
					\uIf{$\eta(a_i, x) = 1 \land \eta(b_i, x) = 1$}{
						$W \gets W \cup \{x, y \}$
						\;
						$R \gets R \cup \{<x,x>, <y,y>, <x,y>, <y,x> \}$
						\;
						\Goto{contacts}
					}
				}
				Unable to construct a model.
			}
			Successfully constructed a model $\M = ((W, R), \upsilon_n)$.
		\end{algorithm}

	\newpage
	\section{Connected Contact Logics}

	\subsection{Connectivity}
	In topology and related branches of mathematics, a connected space is a topological space that cannot be represented as the union of two or more disjoint non-empty open subsets. Connectedness is one of the principal topological properties that are used to distinguish topological spaces.

	\begin{theorem}
		(Connectivity) Let b is a term. Then
		\label{connectivity-theorem}\begin{equation}
			b \neq 0 \land b \neq 1 \implies bCb^*
		\end{equation}
	\end{theorem}

	\paragraph{} Let $\F$ = (W, R) be a relational system with W $\neq$ $\emptyset$, R $\subseteq$ $W^2$ and a, b are terms. Let us recall the deficition of C:
	\begin{equation}
		aCb \iff (\exists x \in \upsilon(a)) (\exists y \in \upsilon(b))(xRy)
	\end{equation}

	\paragraph{} The connectivity theorem can be written as follows:
	\begin{equation}
		\upsilon(b) \neq \emptyset \land \upsilon(b) \neq W \implies (\exists x \in \upsilon(b)) (\exists y \in W \setminus \upsilon(b))(xRy)
	\end{equation}

	\begin{defn}
		Let G = (W, R) be a graph. W is the set of vertexes and R the set of edges. A \textbf{path} $\pi(v_1, v_n)$ is a sequence of vertexes $(v_1, v_2, \dotsc , v_n)$ such that $v_1,\dotsc,v_n \in V$ and $v_iRv_{i+1}$, for $i \in \{1,\dotsc,n-1\}$.
	\end{defn}

	\begin{defn}
		Let $G = (W, R)$ be an undirected graph. $W$ is the set of vertexes and R the set of edges. $G$ is $\mathbf{connected}$ if there is a path between each two vertices in $W$.
		\begin{equation}
			(\forall x \in W)(\forall y \in W)(\exists \pi(x, y)) (\pi(x, y)\;is\;a\;path\;in\;G)
		\end{equation}
	\end{defn}

	The connectivity theorem implies that the evaluation sets are connected. The modal point representation is as variable evaluation. So, the non distinguishable modal points are treated as one modal point. Therefore, the connectivity theorem implies that the graph $G = (W, R)$ is connected.

	\begin{defn}
		Let $\F$ = (W, R) be a relational system. Let $\M = (\F, \upsilon_n)$ be a model of $\beta$. $\M$ is a \textbf{connected model} if $G = (W, R)$ is connected.
	\end{defn}

	\subsection{Connected model building}

		Let $\beta$ be a branch conjunction as in \ref{branch-conjunction} :
		\nonumber\BranchConjunction

		Let $\F^v = (W^v, R^v)$ be a relational system. Let $\M^v = (\F^v, \upsilon_n)$ be a model. $\M^v$ is a model of $\beta$ if the non-zero terms and contacts in $\beta$ are satisfied \ref{satisfied-contacts-non-zero-terms} .	If $\M^v$ is not a model of $\beta$, then $\beta$ does not have a model neither a connected model.

		Let $\M^v$ is a model of $\beta$. $\M^v$ is the biggest model of $\beta$ w.r.t unique modal points and connections between them. Let $G^v=(W^v, R^v)$ be the graph of $\F^v$.

		\begin{defn}
			Let G'=(W', R') and G''=(W'', R'') are an undirected graphs. G' and G' $\mathbf{does \; not \; overlap}$ iff:
			\begin{equation}
				W' \cap W'' = \emptyset \land R' \cap R'' = \emptyset
			\end{equation}
		\end{defn}

		\begin{defn}
			Let $F = (W, R)$ be a relational system. Let $G = (W, R)$ be an undirected graph. Then $Comp^G$ is the splitting of G to it's $\mathbf{connected \; components}$ .
			\begin{align*}
				Comp^G = \{G'=(W', R') \mid W' \subseteq W \land R' \subseteq R \land G'\;is\;connected \} \land \\
				(\forall \; G' \in Comp^G)(\forall \; G'' \in Comp^G)(G' \; and \; G'' \; does \; not \; overlap) \land \\
				\{ W' \mid G'=(W', R') \in Comp^G \} = W \land \{ R' \mid G'=(W', R') \in Comp^G \} = R
			\end{align*}
		\end{defn}

		Let $Comp^{G^v}$ is the set of the connected components of $G^v$. If $Comp^{G^v}$ contains a graph which defines a model of $\beta$, then it is a connected model, too. Otherwise, $\beta$ does not have a connected model.

		Let $G' \in Comp^{G^v}$. Let $\M' = (W', R', \upsilon_n)$ is a model. In order $\M'$ to be a model of $\beta$ the non-zero terms and contacts in $\beta$ should be satisfied \ref{satisfied-contacts-non-zero-terms} . The zero terms and non-contacts are satisfied because $\M'$ has not introduces new modal points neither a connections.

	\newpage
	\section{Implementation Introduction}

	\newpage
	\section{Tableaux Implementation}

	\newpage
	\section{Model Implementation}

	\newpage
	\section{Connected Contact Logics Implementation}

	\newpage
	TODO: separate line for the authors
	\begin{thebibliography}{9}
		\bibitem{Handbook-of-Tableau-Methods}
			Handbook of Tableau Methods
			M. D’Agostino, D. M. Gabbay, R. H¨ahnle and J. Posegga, eds.
		\bibitem{modal-logics-space}
			Modal Logics for Region-based Theories of Space
			Philippe Balbiani, Thinko Tinchev, Dimiter Vakarelov
		\bibitem{connected-space}
			\href{https://en.wikipedia.org/wiki/Connected_space}{Connected Space}
			or go to the next url: \url{https://en.wikipedia.org/wiki/Connected_space}
	\end{thebibliography}
\end{document}\grid
